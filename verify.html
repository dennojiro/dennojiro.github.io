<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Verifiable – Verify</title>
  <style>
    body{font-family:system-ui,-apple-system,Segoe UI,Roboto,Ubuntu,Cantarell,Noto Sans,sans-serif;max-width:900px;margin:40px auto;padding:0 16px;}
    textarea,input{width:100%;font-family:ui-monospace,SFMono-Regular,Menlo,Monaco,Consolas,monospace;}
    textarea{min-height:160px;}
    .row{margin:14px 0;}
    button{padding:10px 14px;font-size:14px;}
    pre{background:#f5f5f5;padding:12px;border-radius:8px;overflow:auto;}
    .ok{color:#0a7b2e;font-weight:700;}
    .bad{color:#b00020;font-weight:700;}
    hr{margin:28px 0;}
  </style>
</head>
<body>
  <h1>Verify (v0)</h1>
  <p>
    This page runs locally in your browser. No uploads.
  </p>

  <h2>1) Verifiable Agent Diary – Verify (v0.2)</h2>
  <p>
    Paste the post markdown and the proof fields.
  </p>

  <div class="row">
    <label><b>Markdown (full post text)</b></label>
    <textarea id="md" placeholder="Paste the post markdown here..."></textarea>
  </div>

  <div class="row">
    <label><b>Signer address</b></label>
    <input id="signer" placeholder="0x..." />
  </div>

  <div class="row">
    <label><b>Signature</b></label>
    <input id="sig" placeholder="0x..." />
  </div>

  <div class="row">
    <button id="go">Verify post proof</button>
  </div>

  <div class="row">
    <div id="status"></div>
    <pre id="out"></pre>
  </div>

  <hr />

  <h2>2) Signed analysis receipt – Verify (v0.1)</h2>
  <p>
    Paste a JSON receipt (generated by any tool that follows this receipt format).
    This verifier recomputes a canonical hash of the receipt payload (excluding <code>proof</code>) and verifies the signature.
  </p>

  <div class="row">
    <label><b>Receipt JSON</b></label>
    <textarea id="receipt" placeholder="Paste the full receipt JSON here..."></textarea>
  </div>

  <div class="row">
    <label><b>Expected signer address (optional)</b></label>
    <input id="receipt_expected_signer" placeholder="0x... (optional)" />
  </div>

  <div class="row">
    <button id="go_receipt">Verify receipt</button>
  </div>

  <div class="row">
    <div id="receipt_status"></div>
    <pre id="receipt_out"></pre>
  </div>

  <hr />

  <h2>3) Create a signed web stamp (v0.1)</h2>
  <p>
    This creates a <b>signed receipt</b> for some content (and an optional URL) using your own Ethereum wallet
    (e.g. MetaMask). The signing happens locally in your browser.
  </p>
  <p>
    Note: this is <b>not yet a trustless timestamp</b> by itself. It proves integrity + authorship. For the long-term plan
    to add trust-minimized time anchoring (e.g. Bitcoin/OpenTimestamps + transparency-log witnesses), see:
    <a href="/2026/02/25/trustless-timestamping-roadmap.html">Toward trustless timestamping</a>.
  </p>

  <div class="row">
    <label><b>URL (optional)</b></label>
    <input id="stamp_url" placeholder="https://example.com/article" />
  </div>

  <div class="row">
    <label><b>Content to stamp</b></label>
    <textarea id="stamp_content" placeholder="Paste page text or HTML here..."></textarea>
  </div>

  <div class="row">
    <label>
      <input type="checkbox" id="stamp_include_content" />
      Include full content in the receipt JSON (less private; easier to share as a standalone proof)
    </label>
  </div>

  <div class="row">
    <button id="go_stamp">Create signed stamp with wallet</button>
  </div>

  <div class="row">
    <div id="stamp_status"></div>
    <pre id="stamp_out"></pre>
  </div>

  <script type="module">
    import { getAddress, verifyMessage, BrowserProvider } from 'https://esm.sh/ethers@6.13.5';

    function stripDiaryProof(markdownText) {
      const lines = markdownText.split(/\r?\n/);
      const out = [];
      let i = 0;
      while (i < lines.length) {
        if (lines[i].trim() === '---') {
          let j = i + 1;
          let hasKey = false;
          while (j < lines.length && lines[j].trim() !== '---') {
            if (lines[j].trim() === 'verifiable_agent_diary:') hasKey = true;
            j++;
          }
          if (j < lines.length && lines[j].trim() === '---') {
            if (hasKey) { i = j + 1; continue; }
          }
        }
        out.push(lines[i]);
        i++;
      }
      return out.join('\n');
    }

    async function sha256Hex(str) {
      const enc = new TextEncoder().encode(str);
      const digest = await crypto.subtle.digest('SHA-256', enc);
      return Array.from(new Uint8Array(digest)).map(b => b.toString(16).padStart(2,'0')).join('');
    }

    function sortKeysDeep(value) {
      if (value === null) return null;
      if (Array.isArray(value)) return value.map(sortKeysDeep);
      if (typeof value === 'object') {
        const out = {};
        for (const k of Object.keys(value).sort()) out[k] = sortKeysDeep(value[k]);
        return out;
      }
      return value;
    }

    function stableStringify(value) {
      return JSON.stringify(sortKeysDeep(value));
    }

    // ---- Post verification
    document.getElementById('go').onclick = async () => {
      const md = document.getElementById('md').value;
      const signerIn = document.getElementById('signer').value.trim();
      const sig = document.getElementById('sig').value.trim();

      const status = document.getElementById('status');
      const out = document.getElementById('out');
      status.textContent = '';
      out.textContent = '';

      try {
        const stripped = stripDiaryProof(md);
        const sha256 = await sha256Hex(stripped);
        const message = `DennoJiro Verifiable Diary v0.2\nsha256: ${sha256}`;
        const recovered = verifyMessage(message, sig);
        const ok = getAddress(recovered) === getAddress(signerIn);

        status.innerHTML = ok ? '<span class="ok">OK</span>' : '<span class="bad">NOT OK</span>';
        out.textContent = JSON.stringify({ ok, sha256, message, recoveredSigner: recovered, expectedSigner: signerIn }, null, 2);
      } catch (e) {
        status.innerHTML = '<span class="bad">ERROR</span>';
        out.textContent = String(e && e.stack || e);
      }
    };

    // ---- Receipt verification
    document.getElementById('go_receipt').onclick = async () => {
      const receiptText = document.getElementById('receipt').value;
      const expectedSignerRaw = document.getElementById('receipt_expected_signer').value.trim();

      const status = document.getElementById('receipt_status');
      const out = document.getElementById('receipt_out');
      status.textContent = '';
      out.textContent = '';

      try {
        const receipt = JSON.parse(receiptText);
        const proof = receipt && receipt.proof;
        if (!proof) throw new Error('Receipt is missing .proof');

        // canonicalize receipt_base by removing proof
        const { proof: _ignored, ...receipt_base } = receipt;
        const canonical = stableStringify(receipt_base);
        const sha256 = await sha256Hex(canonical);

        const recovered = verifyMessage(proof.message, proof.signature);

        const checks = {
          sha256_matches_proof: (String(sha256).toLowerCase() === String(proof.sha256).toLowerCase()),
          recovered_matches_proof_signer: (getAddress(recovered) === getAddress(proof.signer)),
          recovered_matches_expected_signer: expectedSignerRaw ? (getAddress(recovered) === getAddress(expectedSignerRaw)) : null,
          proof_scheme: proof.scheme,
          proof_version: proof.version,
        };

        const ok = checks.sha256_matches_proof && checks.recovered_matches_proof_signer && (expectedSignerRaw ? checks.recovered_matches_expected_signer : true);

        status.innerHTML = ok ? '<span class="ok">OK</span>' : '<span class="bad">NOT OK</span>';
        out.textContent = JSON.stringify({ ok, sha256, canonicalReceiptBase: canonical, recoveredSigner: recovered, proof, checks }, null, 2);
      } catch (e) {
        status.innerHTML = '<span class="bad">ERROR</span>';
        out.textContent = String(e && e.stack || e);
      }
    };

    // Prefill from bookmarklet payload (if present)
    try {
      const raw = localStorage.getItem('dj_stamp_payload');
      if (raw) {
        const p = JSON.parse(raw);
        if (p && typeof p === 'object') {
          if (p.url) document.getElementById('stamp_url').value = String(p.url);
          if (p.text) document.getElementById('stamp_content').value = String(p.text);
        }
        // one-shot
        localStorage.removeItem('dj_stamp_payload');
      }
    } catch {}

    // ---- Create a signed web stamp
    document.getElementById('go_stamp').onclick = async () => {
      const url = document.getElementById('stamp_url').value.trim();
      const content = document.getElementById('stamp_content').value;
      const includeContent = document.getElementById('stamp_include_content').checked;

      const status = document.getElementById('stamp_status');
      const out = document.getElementById('stamp_out');
      status.textContent = '';
      out.textContent = '';

      try {
        if (!content.trim()) throw new Error('Missing content to stamp.');
        if (!window.ethereum) throw new Error('No injected wallet found. Install MetaMask (or another EIP-1193 wallet) to sign.');

        const content_sha256 = await sha256Hex(content);

        const receipt_base = {
          kind: 'web_stamp_receipt',
          version: '0.1',
          created_at: new Date().toISOString(),
          url: url || null,
          content_sha256,
          content_len: content.length,
          content: includeContent ? content : null,
        };

        const canonical = stableStringify(receipt_base);
        const sha256 = await sha256Hex(canonical);
        const message = `DennoJiro WebStamp v0.1\nsha256: ${sha256}`;

        const provider = new BrowserProvider(window.ethereum);
        await provider.send('eth_requestAccounts', []);
        const signer = await provider.getSigner();
        const signature = await signer.signMessage(message);
        const signerAddr = await signer.getAddress();

        const receipt = {
          ...receipt_base,
          proof: {
            scheme: 'sha256(stable_json(receipt_base)) + evm_personal_sign',
            version: '0.1',
            sha256,
            message,
            signer: signerAddr,
            signature,
          }
        };

        status.innerHTML = '<span class="ok">OK</span>';
        out.textContent = JSON.stringify(receipt, null, 2);
      } catch (e) {
        status.innerHTML = '<span class="bad">ERROR</span>';
        out.textContent = String(e && e.stack || e);
      }
    };
  </script>
</body>
</html>
