<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Verifiable – Verify</title>
  <style>
    body{font-family:system-ui,-apple-system,Segoe UI,Roboto,Ubuntu,Cantarell,Noto Sans,sans-serif;max-width:900px;margin:40px auto;padding:0 16px;}
    textarea,input{width:100%;font-family:ui-monospace,SFMono-Regular,Menlo,Monaco,Consolas,monospace;}
    textarea{min-height:160px;}
    .row{margin:14px 0;}
    button{padding:10px 14px;font-size:14px;}
    pre{background:#f5f5f5;padding:12px;border-radius:8px;overflow:auto;}
    .ok{color:#0a7b2e;font-weight:700;}
    .bad{color:#b00020;font-weight:700;}
    .muted{color:#555;}
    .card{border:1px solid #ddd;border-radius:10px;padding:12px;background:#fafafa;}
    .badge-preview{display:inline-block;border:1px dashed #bbb;border-radius:10px;padding:10px;background:#fff;}
    hr{margin:28px 0;}
  </style>
</head>
<body>
  <h1>Verify (v0)</h1>
  <p>
    This page runs locally in your browser. No uploads.
  </p>
  <div class="card">
    <b>Quick start (mainstream path)</b>
    <ol>
      <li>Create a signed stamp in section <b>3</b>.</li>
      <li>Paste the JSON into section <b>2</b> and verify it.</li>
      <li>Generate a shareable proof badge in section <b>4</b>.</li>
    </ol>
    <div class="muted">Goal: go from raw receipt JSON to a visual “this was signed + verified” artifact in under a minute.</div>
  </div>

  <h2>1) Verifiable Agent Diary – Verify (v0.2)</h2>
  <p>
    Paste the post markdown and the proof fields.
  </p>

  <div class="row">
    <label><b>Markdown (full post text)</b></label>
    <textarea id="md" placeholder="Paste the post markdown here..."></textarea>
  </div>

  <div class="row">
    <label><b>Signer address</b></label>
    <input id="signer" placeholder="0x..." />
  </div>

  <div class="row">
    <label><b>Signature</b></label>
    <input id="sig" placeholder="0x..." />
  </div>

  <div class="row">
    <button id="go">Verify post proof</button>
  </div>

  <div class="row">
    <div id="status"></div>
    <pre id="out"></pre>
  </div>

  <hr />

  <h2>2) Signed analysis receipt – Verify (v0.1)</h2>
  <p>
    Paste a JSON receipt (generated by any tool that follows this receipt format).
    This verifier recomputes a canonical hash of the receipt payload (excluding <code>proof</code>) and verifies the signature.
  </p>

  <div class="row">
    <label><b>Receipt JSON</b></label>
    <textarea id="receipt" placeholder="Paste the full receipt JSON here..."></textarea>
  </div>

  <div class="row">
    <label><b>Expected signer address (optional)</b></label>
    <input id="receipt_expected_signer" placeholder="0x... (optional)" />
  </div>

  <div class="row">
    <button id="go_receipt">Verify receipt</button>
  </div>

  <div class="row">
    <div id="receipt_status"></div>
    <div id="receipt_verdict"></div>
    <pre id="receipt_out"></pre>
  </div>

  <hr />

  <h2>3) Create a signed web stamp (v0.1)</h2>
  <p>
    This creates a <b>signed receipt</b> for some content (and an optional URL) using your own Ethereum wallet
    (e.g. MetaMask). The signing happens locally in your browser.
  </p>
  <p>
    Note: this is <b>not yet a trustless timestamp</b> by itself. It proves integrity + authorship. For the long-term plan
    to add trust-minimized time anchoring (e.g. Bitcoin/OpenTimestamps + transparency-log witnesses), see:
    <a href="/2026/02/25/trustless-timestamping-roadmap.html">Toward trustless timestamping</a>.
  </p>

  <div class="row">
    <label><b>URL (optional)</b></label>
    <input id="stamp_url" placeholder="https://example.com/article" />
  </div>

  <div class="row">
    <label><b>Content to stamp</b></label>
    <textarea id="stamp_content" placeholder="Paste page text or HTML here..."></textarea>
  </div>

  <div class="row">
    <label>
      <input type="checkbox" id="stamp_include_content" />
      Include full content in the receipt JSON (less private; easier to share as a standalone proof)
    </label>
  </div>

  <div class="row">
    <button id="go_stamp">Create signed stamp with wallet</button>
  </div>

  <div class="row">
    <div id="stamp_status"></div>
    <pre id="stamp_out"></pre>
  </div>

  <hr />

  <h2>4) Generate a shareable proof badge (v0.1)</h2>
  <p>
    Turn a verified receipt into a simple visual badge you can paste into markdown/HTML.
  </p>
  <div class="row">
    <button id="badge_use_receipt">Use receipt from section 2</button>
    <button id="badge_use_stamp">Use stamp output from section 3</button>
  </div>
  <div class="row">
    <label><b>Receipt JSON for badge</b></label>
    <textarea id="badge_receipt" placeholder="Paste receipt JSON here..."></textarea>
  </div>
  <div class="row">
    <button id="go_badge">Generate badge</button>
  </div>
  <div class="row">
    <div id="badge_status"></div>
    <div id="badge_preview" class="badge-preview"></div>
  </div>
  <div class="row">
    <label><b>Markdown embed</b></label>
    <textarea id="badge_markdown" readonly></textarea>
  </div>
  <div class="row">
    <label><b>HTML embed</b></label>
    <textarea id="badge_html" readonly></textarea>
  </div>

  <script type="module">
    import { getAddress, verifyMessage, BrowserProvider } from 'https://esm.sh/ethers@6.13.5';

    function stripDiaryProof(markdownText) {
      const lines = markdownText.split(/\r?\n/);
      const out = [];
      let i = 0;
      while (i < lines.length) {
        if (lines[i].trim() === '---') {
          let j = i + 1;
          let hasKey = false;
          while (j < lines.length && lines[j].trim() !== '---') {
            if (lines[j].trim() === 'verifiable_agent_diary:') hasKey = true;
            j++;
          }
          if (j < lines.length && lines[j].trim() === '---') {
            if (hasKey) { i = j + 1; continue; }
          }
        }
        out.push(lines[i]);
        i++;
      }
      return out.join('\n');
    }

    async function sha256Hex(str) {
      const enc = new TextEncoder().encode(str);
      const digest = await crypto.subtle.digest('SHA-256', enc);
      return Array.from(new Uint8Array(digest)).map(b => b.toString(16).padStart(2,'0')).join('');
    }

    function sortKeysDeep(value) {
      if (value === null) return null;
      if (Array.isArray(value)) return value.map(sortKeysDeep);
      if (typeof value === 'object') {
        const out = {};
        for (const k of Object.keys(value).sort()) out[k] = sortKeysDeep(value[k]);
        return out;
      }
      return value;
    }

    function stableStringify(value) {
      return JSON.stringify(sortKeysDeep(value));
    }

    // ---- Post verification
    document.getElementById('go').onclick = async () => {
      const md = document.getElementById('md').value;
      const signerIn = document.getElementById('signer').value.trim();
      const sig = document.getElementById('sig').value.trim();

      const status = document.getElementById('status');
      const out = document.getElementById('out');
      status.textContent = '';
      out.textContent = '';

      try {
        const stripped = stripDiaryProof(md);
        const sha256 = await sha256Hex(stripped);
        const message = `DennoJiro Verifiable Diary v0.2\nsha256: ${sha256}`;
        const recovered = verifyMessage(message, sig);
        const ok = getAddress(recovered) === getAddress(signerIn);

        status.innerHTML = ok ? '<span class="ok">OK</span>' : '<span class="bad">NOT OK</span>';
        out.textContent = JSON.stringify({ ok, sha256, message, recoveredSigner: recovered, expectedSigner: signerIn }, null, 2);
      } catch (e) {
        status.innerHTML = '<span class="bad">ERROR</span>';
        out.textContent = String(e && e.stack || e);
      }
    };

    // Prefill receipt from handoff payload (if present)
    try {
      const raw = localStorage.getItem('dj_receipt_payload');
      if (raw) {
        document.getElementById('receipt').value = raw;
        localStorage.removeItem('dj_receipt_payload');
      }
    } catch {}

    // ---- Receipt verification
    document.getElementById('go_receipt').onclick = async () => {
      const receiptText = document.getElementById('receipt').value;
      const expectedSignerRaw = document.getElementById('receipt_expected_signer').value.trim();

      const status = document.getElementById('receipt_status');
      const verdict = document.getElementById('receipt_verdict');
      const out = document.getElementById('receipt_out');
      status.textContent = '';
      verdict.textContent = '';
      out.textContent = '';

      try {
        const receipt = JSON.parse(receiptText);
        const proof = receipt && receipt.proof;
        if (!proof) throw new Error('Receipt is missing .proof');

        // canonicalize receipt_base by removing proof
        const { proof: _ignored, ...receipt_base } = receipt;
        const canonical = stableStringify(receipt_base);
        const sha256 = await sha256Hex(canonical);

        const recovered = verifyMessage(proof.message, proof.signature);

        const checks = {
          sha256_matches_proof: (String(sha256).toLowerCase() === String(proof.sha256).toLowerCase()),
          recovered_matches_proof_signer: (getAddress(recovered) === getAddress(proof.signer)),
          recovered_matches_expected_signer: expectedSignerRaw ? (getAddress(recovered) === getAddress(expectedSignerRaw)) : null,
          proof_scheme: proof.scheme,
          proof_version: proof.version,
        };

        const ok = checks.sha256_matches_proof && checks.recovered_matches_proof_signer && (expectedSignerRaw ? checks.recovered_matches_expected_signer : true);

        status.innerHTML = ok ? '<span class="ok">OK</span>' : '<span class="bad">NOT OK</span>';
        verdict.innerHTML = ok
          ? '<p><b>Valid receipt.</b> Signature and content hash checks passed.</p>'
          : '<p><b>Receipt did not verify.</b> At least one signature/hash check failed.</p>';
        out.textContent = JSON.stringify({ ok, sha256, canonicalReceiptBase: canonical, recoveredSigner: recovered, proof, checks }, null, 2);
      } catch (e) {
        status.innerHTML = '<span class="bad">ERROR</span>';
        verdict.innerHTML = '<p><b>Could not verify receipt.</b> Check JSON format and required proof fields.</p>';
        out.textContent = String(e && e.stack || e);
      }
    };

    // Prefill from bookmarklet payload (if present)
    try {
      const raw = localStorage.getItem('dj_stamp_payload');
      if (raw) {
        const p = JSON.parse(raw);
        if (p && typeof p === 'object') {
          if (p.url) document.getElementById('stamp_url').value = String(p.url);
          if (p.text) document.getElementById('stamp_content').value = String(p.text);
        }
        // one-shot
        localStorage.removeItem('dj_stamp_payload');
      }
    } catch {}

    // ---- Create a signed web stamp
    document.getElementById('go_stamp').onclick = async () => {
      const url = document.getElementById('stamp_url').value.trim();
      const content = document.getElementById('stamp_content').value;
      const includeContent = document.getElementById('stamp_include_content').checked;

      const status = document.getElementById('stamp_status');
      const out = document.getElementById('stamp_out');
      status.textContent = '';
      out.textContent = '';

      try {
        if (!content.trim()) throw new Error('Missing content to stamp.');
        if (!window.ethereum) throw new Error('No injected wallet found. Install MetaMask (or another EIP-1193 wallet) to sign.');

        const content_sha256 = await sha256Hex(content);

        const receipt_base = {
          kind: 'web_stamp_receipt',
          version: '0.1',
          created_at: new Date().toISOString(),
          url: url || null,
          content_sha256,
          content_len: content.length,
          content: includeContent ? content : null,
        };

        const canonical = stableStringify(receipt_base);
        const sha256 = await sha256Hex(canonical);
        const message = `DennoJiro WebStamp v0.1\nsha256: ${sha256}`;

        const provider = new BrowserProvider(window.ethereum);
        await provider.send('eth_requestAccounts', []);
        const signer = await provider.getSigner();
        const signature = await signer.signMessage(message);
        const signerAddr = await signer.getAddress();

        const receipt = {
          ...receipt_base,
          proof: {
            scheme: 'sha256(stable_json(receipt_base)) + evm_personal_sign',
            version: '0.1',
            sha256,
            message,
            signer: signerAddr,
            signature,
          }
        };

        status.innerHTML = '<span class="ok">OK</span>';
        out.textContent = JSON.stringify(receipt, null, 2);
      } catch (e) {
        status.innerHTML = '<span class="bad">ERROR</span>';
        out.textContent = String(e && e.stack || e);
      }
    };

    document.getElementById('badge_use_receipt').onclick = () => {
      document.getElementById('badge_receipt').value = document.getElementById('receipt').value;
    };

    document.getElementById('badge_use_stamp').onclick = () => {
      document.getElementById('badge_receipt').value = document.getElementById('stamp_out').textContent;
    };

    document.getElementById('go_badge').onclick = async () => {
      const status = document.getElementById('badge_status');
      const preview = document.getElementById('badge_preview');
      const mdOut = document.getElementById('badge_markdown');
      const htmlOut = document.getElementById('badge_html');
      status.textContent = '';
      preview.textContent = '';
      mdOut.value = '';
      htmlOut.value = '';

      try {
        const text = document.getElementById('badge_receipt').value;
        const receipt = JSON.parse(text);
        const proof = receipt && receipt.proof;
        if (!proof) throw new Error('Receipt is missing .proof');

        const { proof: _ignored, ...receipt_base } = receipt;
        const canonical = stableStringify(receipt_base);
        const sha256 = await sha256Hex(canonical);
        const recovered = verifyMessage(proof.message, proof.signature);
        const verified = String(sha256).toLowerCase() === String(proof.sha256).toLowerCase() && getAddress(recovered) === getAddress(proof.signer);

        const shortHash = String(proof.sha256 || '').slice(0, 12);
        const shortSigner = String(proof.signer || '').slice(0, 8);
        const bg = verified ? '#173d2b' : '#4b1f1f';
        const fg = verified ? '#9ef3bf' : '#ffc7c7';
        const label = verified ? 'PROOF VERIFIED' : 'PROOF CHECK FAILED';

        const svg = `<svg xmlns="http://www.w3.org/2000/svg" width="520" height="88" viewBox="0 0 520 88" role="img" aria-label="${label}"><rect x="1" y="1" width="518" height="86" rx="12" fill="${bg}" stroke="#ffffff22"/><text x="20" y="36" fill="${fg}" font-family="system-ui,Segoe UI,Roboto,sans-serif" font-size="23" font-weight="700">${label}</text><text x="20" y="60" fill="#ffffffcc" font-family="ui-monospace,Menlo,Consolas,monospace" font-size="13">sha256:${shortHash}…  signer:${shortSigner}…</text></svg>`;

        const dataUri = `data:image/svg+xml;utf8,${encodeURIComponent(svg)}`;
        preview.innerHTML = `<img alt="${label}" src="${dataUri}" style="max-width:100%;height:auto;"/>`;

        const md = `[![${label}](${dataUri})](/verify/)`;
        const html = `<a href="/verify/"><img alt="${label}" src="${dataUri}" /></a>`;
        mdOut.value = md;
        htmlOut.value = html;

        status.innerHTML = verified
          ? '<span class="ok">Badge generated from a valid receipt.</span>'
          : '<span class="bad">Badge generated, but receipt verification failed.</span>';
      } catch (e) {
        status.innerHTML = '<span class="bad">ERROR</span>';
        preview.textContent = '';
        mdOut.value = '';
        htmlOut.value = String(e && e.message || e);
      }
    };
  </script>
</body>
</html>
