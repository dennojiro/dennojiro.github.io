<!doctype html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Mediterranean Chase Prototype</title>
  <style>
    html, body { margin: 0; height: 100%; overflow: hidden; background: #0d1f35; color: #eaf2ff; font-family: Inter, system-ui, sans-serif; }
    #overlay, #finish {
      position: fixed; inset: 0; display: grid; place-items: center; z-index: 20;
      background: linear-gradient(rgba(9,16,33,.72), rgba(9,16,33,.72));
      backdrop-filter: blur(2px);
    }
    #finish { display: none; z-index: 25; }
    .card {
      width: min(720px, calc(100vw - 32px)); border-radius: 14px; padding: 18px 20px;
      border: 1px solid rgba(148,163,184,.4); background: rgba(9,16,33,.9);
      box-shadow: 0 20px 48px rgba(0,0,0,.34);
    }
    button, select {
      margin-top: 12px; border: 0; border-radius: 9px; padding: 10px 14px; font-weight: 700;
      color: white; background: #2b79ff;
    }
    select { background: #1f3f73; }
    #hud {
      position: fixed; top: 10px; left: 10px; z-index: 10; min-width: 380px;
      border-radius: 10px; padding: 10px 12px; border: 1px solid rgba(148,163,184,.36);
      background: rgba(9,16,33,.74); font-size: 13px; line-height: 1.35;
    }
    #msg { color: #a6f2c4; min-height: 18px; margin-top: 4px; }
    #crosshair { position: fixed; left: 50%; top: 50%; width: 12px; height: 12px; margin-left: -6px; margin-top: -6px; pointer-events: none; z-index: 9; }
    #crosshair::before, #crosshair::after { content:""; position:absolute; background:#f4fbff; }
    #crosshair::before { left:0; top:5px; width:12px; height:2px; }
    #crosshair::after { left:5px; top:0; width:2px; height:12px; }
  </style>
</head>
<body>
  <div id="hud">
    <div><strong>Mode:</strong> <span id="modeLabel">Chase</span> · <strong>Quality:</strong> <span id="qLabel">High</span></div>
    <div><strong>Distance:</strong> <span id="dist">--</span>m · <strong>Rubber-band:</strong> <span id="rb">neutral</span></div>
    <div><strong>Catches:</strong> <span id="score">0</span> · <strong>Time:</strong> <span id="time">0.0</span>s</div>
    <div><strong>Assets:</strong> <span id="assetStatus">loading...</span></div>
    <div>WASD move · Mouse look · E interact/tag · Esc unlock</div>
    <div id="msg">Track the suspect through the old city alleys.</div>
  </div>
  <div id="crosshair"></div>

  <div id="overlay">
    <div class="card">
      <h2 style="margin:0 0 10px;">Mediterranean City Chase Prototype</h2>
      <p style="margin:0 0 8px;">Catch the fleeing spy across steep streets, plazas, and harbor lanes. The suspect adapts speed based on your performance (rubber-banding).</p>
      <label>Game mode:
        <select id="modeSel">
          <option value="chase">Chase (core)</option>
          <option value="tag">Hide-and-seek / Tag</option>
        </select>
      </label>
      <label style="margin-left:10px;">Performance:
        <select id="qualitySel">
          <option value="high">High</option>
          <option value="low">Low</option>
        </select>
      </label>
      <button id="startBtn">Start</button>
    </div>
  </div>

  <div id="finish">
    <div class="card">
      <h2 style="margin:0 0 8px;color:#97f4b8;">Catch Confirmed ✅</h2>
      <p id="finishText" style="margin:0 0 8px;"></p>
      <button id="againBtn">Play Again</button>
    </div>
  </div>

  <script type="module">
    import * as THREE from 'https://cdn.jsdelivr.net/npm/three@0.161/build/three.module.js';

    const scene = new THREE.Scene();
    scene.fog = new THREE.Fog(0x9ec9ff, 65, 300);

    const camera = new THREE.PerspectiveCamera(75, innerWidth / innerHeight, 0.1, 900);
    const renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setSize(innerWidth, innerHeight);
    renderer.setPixelRatio(Math.min(devicePixelRatio, 2));
    renderer.shadowMap.enabled = true;
    renderer.shadowMap.type = THREE.PCFSoftShadowMap;
    document.body.appendChild(renderer.domElement);

    const hemi = new THREE.HemisphereLight(0xd8ebff, 0x3a2e23, 0.95);
    const sun = new THREE.DirectionalLight(0xffffff, 1.1);
    sun.position.set(80, 130, 40);
    sun.castShadow = true;
    sun.shadow.mapSize.set(1024, 1024);
    sun.shadow.camera.left = -180;
    sun.shadow.camera.right = 180;
    sun.shadow.camera.top = 180;
    sun.shadow.camera.bottom = -180;
    scene.add(hemi, sun);

    const sky = new THREE.Mesh(
      new THREE.SphereGeometry(700, 32, 16),
      new THREE.ShaderMaterial({
        side: THREE.BackSide,
        uniforms: {
          top: { value: new THREE.Color(0x78b8ff) },
          bottom: { value: new THREE.Color(0xf1cfa6) }
        },
        vertexShader: `varying vec3 vPos; void main(){ vPos=position; gl_Position=projectionMatrix*modelViewMatrix*vec4(position,1.0); }`,
        fragmentShader: `uniform vec3 top; uniform vec3 bottom; varying vec3 vPos; void main(){ float h=normalize(vPos).y*0.5+0.5; gl_FragColor=vec4(mix(bottom,top,smoothstep(0.0,1.0,h)),1.0);} `
      })
    );
    scene.add(sky);

    const sunGlow = new THREE.Sprite(new THREE.SpriteMaterial({ color: 0xffe4a0, transparent: true, opacity: 0.5 }));
    sunGlow.scale.set(34, 34, 1);
    sunGlow.position.set(130, 120, -80);
    scene.add(sunGlow);

    const cloudMat = new THREE.MeshBasicMaterial({ color: 0xffffff, transparent: true, opacity: 0.16 });
    const clouds = [];
    for (let i = 0; i < 22; i++) {
      const c = new THREE.Mesh(new THREE.PlaneGeometry(24 + Math.random() * 32, 8 + Math.random() * 6), cloudMat);
      c.position.set(-180 + Math.random() * 360, 62 + Math.random() * 36, -180 + Math.random() * 360);
      c.rotation.x = -Math.PI / 2;
      scene.add(c); clouds.push(c);
    }

    const worldMin = -200, worldMax = 200, eyeHeight = 1.7;
    function terrainHeight(x, z) {
      const h = Math.sin(x * 0.022) * 3.4 + Math.cos(z * 0.02) * 2.6
        + Math.exp(-((x + 44) ** 2 + (z + 64) ** 2) / 11800) * 12
        + Math.exp(-((x - 88) ** 2 + (z - 28) ** 2) / 9200) * 10;
      if (x > 68) return THREE.MathUtils.lerp(h, -2.9, THREE.MathUtils.smoothstep(x, 68, 128));
      return h;
    }

    const groundGeo = new THREE.PlaneGeometry(450, 450, 120, 120);
    const pos = groundGeo.attributes.position;
    for (let i = 0; i < pos.count; i++) pos.setZ(i, terrainHeight(pos.getX(i), pos.getY(i)));
    groundGeo.computeVertexNormals();
    const ground = new THREE.Mesh(groundGeo, new THREE.MeshStandardMaterial({ color: 0xcab28c, roughness: .98 }));
    ground.rotation.x = -Math.PI / 2;
    ground.receiveShadow = true;
    scene.add(ground);

    const water = new THREE.Mesh(new THREE.PlaneGeometry(190, 460), new THREE.MeshStandardMaterial({ color: 0x2f86bc, roughness: .22, transparent: true, opacity: .9 }));
    water.rotation.x = -Math.PI / 2; water.position.set(132, -3.2, 0); scene.add(water);

    const buildingColliders = [];
    const staticDecor = [];
    const npcs = [];
    const animatedProps = [];

    function pushDecor(o) {
      staticDecor.push(o);
      o.traverse?.((n) => { if (n.isMesh) { n.castShadow = true; n.receiveShadow = true; } });
      scene.add(o);
    }

    const bColors = [0xf2dfbd, 0xe4cda5, 0xd8be95, 0xf4e5ca, 0xe9d7b5, 0xf7e6d0];
    const roofColors = [0x9d4730, 0xb35e3e, 0x8a3a2b, 0xa9533a];
    for (let i = 0; i < 250; i++) {
      const x = -170 + Math.random() * 240, z = -170 + Math.random() * 340;
      if (x > 72 || terrainHeight(x, z) < -0.8) continue;
      const y = terrainHeight(x, z);
      const w = 4 + Math.random() * 5.2, d = 4 + Math.random() * 5, h = 5 + Math.random() * 16;
      const g = new THREE.Group();
      const body = new THREE.Mesh(new THREE.BoxGeometry(w, h, d), new THREE.MeshStandardMaterial({ color: bColors[(Math.random() * bColors.length) | 0], roughness: .86 }));
      body.position.y = h / 2;
      const roof = new THREE.Mesh(new THREE.ConeGeometry(Math.max(w, d) * .64, Math.max(.8, h * .12), 4), new THREE.MeshStandardMaterial({ color: roofColors[(Math.random() * roofColors.length) | 0], roughness: .92 }));
      roof.rotation.y = Math.PI * 0.25; roof.position.y = h + 0.55;
      g.add(body, roof);
      if (Math.random() < .6) {
        const arch = new THREE.Mesh(new THREE.TorusGeometry(0.6, 0.15, 8, 16, Math.PI), new THREE.MeshStandardMaterial({ color: 0xcfb892, roughness: .9 }));
        arch.rotation.z = Math.PI; arch.position.set(0, 1.3, d * 0.51); g.add(arch);
      }
      g.position.set(x, y, z);
      pushDecor(g);
      buildingColliders.push({ x, z, r: Math.max(w, d) * .56 + .55 });
    }

    // streets
    const roadMat = new THREE.MeshStandardMaterial({ color: 0xb6a98d, roughness: 0.96 });
    function addPath(x1, z1, x2, z2, width = 4.2, steps = 22) {
      for (let i = 0; i <= steps; i++) {
        const t = i / steps, x = THREE.MathUtils.lerp(x1, x2, t), z = THREE.MathUtils.lerp(z1, z2, t);
        const tile = new THREE.Mesh(new THREE.BoxGeometry(width, .2, width * .84), roadMat);
        tile.position.set(x, terrainHeight(x, z) + .05, z);
        tile.rotation.y = Math.atan2(x2 - x1, z2 - z1);
        pushDecor(tile);
      }
    }
    [[-150,-110,-90,-42],[-90,-42,-20,-6],[-20,-6,58,18],[-86,72,-6,40],[-6,40,54,78],[-26,96,34,126],[-8,-92,44,-56],[-60,120,16,146],[-124,18,-40,26]].forEach(p=>addPath(...p));

    // street furniture
    const lampMat = new THREE.MeshStandardMaterial({ color: 0x2b3242, roughness: .65, metalness: .55 });
    const benchMat = new THREE.MeshStandardMaterial({ color: 0x81593b, roughness: .85 });
    const planterMat = new THREE.MeshStandardMaterial({ color: 0x9c8f7b, roughness: .95 });

    function addLamp(x, z) {
      const y = terrainHeight(x, z);
      const g = new THREE.Group();
      const pole = new THREE.Mesh(new THREE.CylinderGeometry(.13, .18, 4.4, 8), lampMat);
      pole.position.y = 2.2;
      const arm = new THREE.Mesh(new THREE.BoxGeometry(1.2, .13, .13), lampMat);
      arm.position.set(.54, 4.1, 0);
      const bulb = new THREE.Mesh(new THREE.SphereGeometry(.16, 8, 8), new THREE.MeshStandardMaterial({ color: 0xffe8a1, emissive: 0xffcc66, emissiveIntensity: .3 }));
      bulb.position.set(1.04, 3.96, 0);
      g.add(pole, arm, bulb);
      g.position.set(x, y, z);
      pushDecor(g);
    }

    function addBench(x, z, rot = 0) {
      const y = terrainHeight(x, z);
      const g = new THREE.Group();
      const seat = new THREE.Mesh(new THREE.BoxGeometry(1.9, .16, .55), benchMat);
      seat.position.y = .6;
      const back = new THREE.Mesh(new THREE.BoxGeometry(1.9, .5, .14), benchMat);
      back.position.set(0, .95, -.2);
      const legMat = new THREE.MeshStandardMaterial({ color: 0x2c2a2a, roughness: .8 });
      [-.8, .8].forEach((lx) => {
        const leg1 = new THREE.Mesh(new THREE.BoxGeometry(.12, .6, .12), legMat);
        leg1.position.set(lx, .3, .18);
        const leg2 = leg1.clone(); leg2.position.z = -.18;
        g.add(leg1, leg2);
      });
      g.add(seat, back);
      g.position.set(x, y + .02, z);
      g.rotation.y = rot;
      pushDecor(g);
    }

    function addPlanter(x, z) {
      const y = terrainHeight(x, z);
      const g = new THREE.Group();
      const pot = new THREE.Mesh(new THREE.CylinderGeometry(.62, .7, .72, 10), planterMat);
      pot.position.y = .36;
      const trunk = new THREE.Mesh(new THREE.CylinderGeometry(.08, .1, .7, 7), new THREE.MeshStandardMaterial({ color: 0x6d4a2f, roughness: .95 }));
      trunk.position.y = .9;
      const crown = new THREE.Mesh(new THREE.SphereGeometry(.55, 9, 8), new THREE.MeshStandardMaterial({ color: 0x4f8c4f, roughness: .9 }));
      crown.position.y = 1.5;
      g.add(pot, trunk, crown);
      g.position.set(x, y, z);
      pushDecor(g);
    }

    for (let i = -130; i <= 48; i += 28) addLamp(i, -44);
    for (let i = -90; i <= 30; i += 24) addBench(i, 42, Math.PI * 0.1);
    [[-64,40],[-32,38],[12,66],[26,92],[-20,-20],[38,26]].forEach(([x,z]) => addPlanter(x, z));

    // harbor details
    function addDock(x, z, w = 10, d = 3) {
      const y = -2.6;
      const deck = new THREE.Mesh(new THREE.BoxGeometry(w, .4, d), new THREE.MeshStandardMaterial({ color: 0x8d6c49, roughness: .93 }));
      deck.position.set(x, y, z);
      pushDecor(deck);
      for (let i = -1; i <= 1; i += 2) {
        const post = new THREE.Mesh(new THREE.CylinderGeometry(.22, .24, 2.2, 8), new THREE.MeshStandardMaterial({ color: 0x544437, roughness: .95 }));
        post.position.set(x + i * (w * .4), y - 1, z + d * .35);
        pushDecor(post);
      }
    }

    function addBoatFallback(x, z, scale = 1) {
      const g = new THREE.Group();
      const hull = new THREE.Mesh(new THREE.BoxGeometry(4.6 * scale, .8 * scale, 1.6 * scale), new THREE.MeshStandardMaterial({ color: 0xc54f35, roughness: .7 }));
      const cabin = new THREE.Mesh(new THREE.BoxGeometry(1.5 * scale, .8 * scale, 1.2 * scale), new THREE.MeshStandardMaterial({ color: 0xf3e8d8, roughness: .86 }));
      cabin.position.y = .75 * scale;
      g.add(hull, cabin);
      g.position.set(x, -2.3, z);
      pushDecor(g);
      return g;
    }

    [[90, -100], [98, -28], [104, 30], [114, 86]].forEach(([x,z]) => addDock(x, z, 10 + Math.random() * 4, 2.8 + Math.random() * .8));
    const fallbackBoats = [[122,-74],[128,-10],[136,56]].map(([x,z]) => addBoatFallback(x, z, 0.9 + Math.random() * .3));

    // asset loader + fallbacks
    let loader = null;
    try {
      const mod = await import('https://esm.sh/three@0.161/examples/jsm/loaders/GLTFLoader.js');
      loader = new mod.GLTFLoader();
    } catch (err) {
      console.warn('GLTFLoader unavailable; continuing with primitive fallback assets.', err);
    }

    const suspect = new THREE.Group(); scene.add(suspect);
    let suspectVisualLoaded = false;
    const assetLog = [];
    const loadedAssets = { ok: 0, fail: 0 };

    const ui = {
      overlay: document.getElementById('overlay'),
      finish: document.getElementById('finish'),
      finishText: document.getElementById('finishText'),
      modeSel: document.getElementById('modeSel'),
      qualitySel: document.getElementById('qualitySel'),
      modeLabel: document.getElementById('modeLabel'),
      qLabel: document.getElementById('qLabel'),
      dist: document.getElementById('dist'),
      rb: document.getElementById('rb'),
      score: document.getElementById('score'),
      time: document.getElementById('time'),
      msg: document.getElementById('msg'),
      assetStatus: document.getElementById('assetStatus')
    };

    function refreshAssetStatus() {
      ui.assetStatus.textContent = `${loadedAssets.ok} loaded / ${loadedAssets.fail} fallback`;
    }

    function fallbackSuspect() {
      const body = new THREE.Mesh(new THREE.CapsuleGeometry(.43, 1.2, 4, 8), new THREE.MeshStandardMaterial({ color: 0x2d3f66 }));
      body.position.y = 1.2;
      const head = new THREE.Mesh(new THREE.SphereGeometry(.3, 12, 12), new THREE.MeshStandardMaterial({ color: 0xf0d0b1 }));
      head.position.y = 2.15;
      suspect.add(body, head);
    }
    fallbackSuspect();

    function loadAsset(url, onOk, onFail) {
      if (!loader) {
        loadedAssets.fail += 1;
        assetLog.push(`fallback(loader): ${url}`);
        onFail?.();
        refreshAssetStatus();
        return;
      }
      loader.load(url, (gltf) => {
        loadedAssets.ok += 1;
        assetLog.push(`loaded: ${url}`);
        onOk(gltf.scene);
        refreshAssetStatus();
      }, undefined, () => {
        loadedAssets.fail += 1;
        assetLog.push(`fallback(load-fail): ${url}`);
        onFail?.();
        refreshAssetStatus();
      });
    }

    // main suspect model (improved)
    loadAsset('https://threejs.org/examples/models/gltf/Soldier.glb', (obj) => {
      suspect.clear();
      obj.scale.set(1.2, 1.2, 1.2);
      suspect.add(obj);
      suspectVisualLoaded = true;
    }, fallbackSuspect);

    // city landmark block with fallback tower
    const landmarkAnchor = new THREE.Group();
    landmarkAnchor.position.set(-165, terrainHeight(-165, 145), 145);
    scene.add(landmarkAnchor);
    const fallbackTower = new THREE.Mesh(new THREE.CylinderGeometry(5, 7, 28, 10), new THREE.MeshStandardMaterial({ color: 0xd7c29d, roughness: .88 }));
    fallbackTower.position.y = 14; landmarkAnchor.add(fallbackTower);
    staticDecor.push(landmarkAnchor);

    loadAsset('https://threejs.org/examples/models/gltf/LittlestTokyo.glb', (obj) => {
      landmarkAnchor.clear();
      obj.scale.set(.12, .12, .12); obj.rotation.y = Math.PI * 0.7;
      landmarkAnchor.add(obj);
    });

    // prop set for harbor and plaza
    const propSpawns = [[92,-80],[98,-20],[102,34],[108,92],[-42,46],[-18,74]];
    propSpawns.forEach(([x,z], i) => {
      const anchor = new THREE.Group();
      anchor.position.set(x, x > 80 ? -2.6 : terrainHeight(x, z), z);
      const fb = new THREE.Mesh(new THREE.BoxGeometry(1.8,1.4,1.8), new THREE.MeshStandardMaterial({ color: 0x8a6a4a, roughness:.95 }));
      anchor.add(fb);
      scene.add(anchor);
      staticDecor.push(anchor);
      const url = i % 2 === 0
        ? 'https://threejs.org/examples/models/gltf/DamagedHelmet/glTF-Binary/DamagedHelmet.glb'
        : 'https://cdn.jsdelivr.net/gh/KhronosGroup/glTF-Sample-Models@master/2.0/BoomBox/glTF-Binary/BoomBox.glb';
      loadAsset(url, (obj) => {
        anchor.clear();
        obj.scale.set(1.1, 1.1, 1.1);
        obj.rotation.y = Math.random() * Math.PI;
        anchor.add(obj);
      });
    });

    // additional NPC variety (civilian + birds)
    function spawnNPCFallback(x, z, color = 0x6672a3) {
      const g = new THREE.Group();
      const body = new THREE.Mesh(new THREE.CapsuleGeometry(.32, .9, 4, 8), new THREE.MeshStandardMaterial({ color }));
      const head = new THREE.Mesh(new THREE.SphereGeometry(.22, 10, 10), new THREE.MeshStandardMaterial({ color: 0xf0d0b1 }));
      body.position.y = .95; head.position.y = 1.75;
      g.add(body, head);
      g.position.set(x, terrainHeight(x, z), z);
      scene.add(g);
      npcs.push({ mesh: g, baseY: g.position.y, phase: Math.random() * Math.PI * 2 });
      return g;
    }

    const civilianSpots = [[-74,22],[-38,56],[18,58],[-12,-22]];
    civilianSpots.forEach(([x,z], idx) => {
      const fallback = spawnNPCFallback(x, z, idx % 2 ? 0x9f7c59 : 0x5c6b92);
      loadAsset('https://cdn.jsdelivr.net/gh/KhronosGroup/glTF-Sample-Models@master/2.0/CesiumMan/glTF-Binary/CesiumMan.glb', (obj) => {
        fallback.clear();
        obj.scale.set(1.08, 1.08, 1.08);
        fallback.add(obj);
      });
    });

    const birdSpots = [[120,-94],[134,14],[144,72]];
    birdSpots.forEach(([x,z], idx) => {
      const anchor = new THREE.Group();
      anchor.position.set(x, -2.2 + Math.random() * 0.6, z);
      const fallback = new THREE.Mesh(new THREE.SphereGeometry(.25, 8, 8), new THREE.MeshStandardMaterial({ color: 0xf7f7f7 }));
      anchor.add(fallback);
      scene.add(anchor);
      animatedProps.push(anchor);
      staticDecor.push(anchor);
      const url = idx % 2 === 0
        ? 'https://threejs.org/examples/models/gltf/Parrot.glb'
        : 'https://threejs.org/examples/models/gltf/Flamingo.glb';
      loadAsset(url, (obj) => {
        anchor.clear();
        obj.scale.set(.018, .018, .018);
        anchor.add(obj);
      });
    });

    // boat model swap (harbor detail)
    const boatAnchor = new THREE.Group();
    boatAnchor.position.set(132, -2.35, 26);
    scene.add(boatAnchor);
    staticDecor.push(boatAnchor);
    boatAnchor.add(new THREE.Mesh(new THREE.BoxGeometry(3.8, .9, 1.7), new THREE.MeshStandardMaterial({ color: 0xb94d39, roughness: .8 })));
    loadAsset('https://cdn.jsdelivr.net/gh/KhronosGroup/glTF-Sample-Models@master/2.0/Duck/glTF-Binary/Duck.glb', (obj) => {
      boatAnchor.clear();
      obj.scale.set(0.036, 0.036, 0.036);
      obj.rotation.y = Math.PI * 0.35;
      boatAnchor.add(obj);
    });

    const state = { forward:false, back:false, left:false, right:false, canControl:false };
    const player = { x:-8, z:-8, yaw:0, pitch:0 };
    const velocity = new THREE.Vector3();
    const move = new THREE.Vector3();
    const tempF = new THREE.Vector3();
    const tempR = new THREE.Vector3();
    const baseMove = 11.2;

    const suspectState = {
      path: [[-98,-78],[-60,-34],[-16,10],[28,42],[58,84],[20,106],[-26,92],[-84,52],[-120,8],[-104,-44]],
      wp: 0,
      speedBase: 7.2,
      mode: 'chase',
      hideTimer: 0,
      visible: true,
      catches: 0,
      started: 0
    };

    const hideSpots = [[-98,78],[-16,82],[36,64],[-72,-18],[18,-56]].map(([x,z]) => new THREE.Vector3(x, terrainHeight(x,z), z));

    let quality = 'high';
    let cullDistance = 175;
    function applyQuality(q) {
      quality = q;
      const low = q === 'low';
      renderer.setPixelRatio(Math.min(devicePixelRatio, low ? 1.05 : 2));
      cullDistance = low ? 92 : 175;
      clouds.forEach(c => c.visible = !low);
      npcs.forEach((n, i) => { n.mesh.visible = low ? (i % 2 === 0) : true; });
      fallbackBoats.forEach((b, i) => { b.visible = low ? i === 0 : true; });
      ui.qLabel.textContent = low ? 'Low' : 'High';
    }

    let dragLook = false;
    function lockPointer() {
      if (document.body.requestPointerLock) document.body.requestPointerLock();
    }
    function startRun() {
      suspectState.mode = ui.modeSel.value;
      ui.modeLabel.textContent = suspectState.mode === 'chase' ? 'Chase' : 'Hide & Seek Tag';
      applyQuality(ui.qualitySel.value);
      suspectState.catches = 0; ui.score.textContent = '0'; ui.finish.style.display = 'none';
      suspectState.started = performance.now();
      state.canControl = true;
      ui.overlay.style.display = 'none';
      lockPointer();
      ui.msg.textContent = suspectState.mode === 'chase' ? 'Close in and tag the suspect.' : 'Find, reveal, then tag with E.';
    }
    document.getElementById('startBtn').addEventListener('click', startRun);
    document.getElementById('againBtn').addEventListener('click', lockPointer);

    document.addEventListener('pointerlockchange', () => {
      const locked = document.pointerLockElement === document.body;
      if (locked) {
        state.canControl = true;
        ui.overlay.style.display = 'none';
      } else if (!dragLook) {
        ui.overlay.style.display = state.canControl ? 'none' : 'grid';
      }
    });

    document.addEventListener('mousedown', (e) => {
      if (!state.canControl) return;
      if (document.pointerLockElement !== document.body && e.button === 0) dragLook = true;
    });
    document.addEventListener('mouseup', () => { dragLook = false; });

    document.addEventListener('mousemove', e => {
      if (!state.canControl) return;
      const canLook = document.pointerLockElement === document.body || dragLook;
      if (!canLook) return;
      player.yaw -= e.movementX * .0021;
      player.pitch = THREE.MathUtils.clamp(player.pitch - e.movementY * .0018, -Math.PI/2 + .02, Math.PI/2 - .02);
    });

    document.addEventListener('keydown', e => {
      if (e.code === 'KeyW') state.forward = true;
      if (e.code === 'KeyS') state.back = true;
      if (e.code === 'KeyA') state.left = true;
      if (e.code === 'KeyD') state.right = true;
      if (e.code === 'KeyE') tryTag(true);
    });
    document.addEventListener('keyup', e => {
      if (e.code === 'KeyW') state.forward = false;
      if (e.code === 'KeyS') state.back = false;
      if (e.code === 'KeyA') state.left = false;
      if (e.code === 'KeyD') state.right = false;
    });

    function resolveCollide(nx, nz) {
      let x = nx, z = nz;
      for (const b of buildingColliders) {
        const dx = x - b.x, dz = z - b.z, d2 = dx*dx + dz*dz, r2 = b.r*b.r;
        if (d2 < r2) {
          const d = Math.sqrt(Math.max(1e-4, d2));
          const push = (b.r - d) + .07;
          x += (dx/d)*push; z += (dz/d)*push;
        }
      }
      return {x,z};
    }

    function updateCulling(px, pz) {
      const c2 = cullDistance * cullDistance;
      for (const o of staticDecor) {
        const dx = o.position.x - px, dz = o.position.z - pz;
        o.visible = (dx*dx + dz*dz) < c2;
      }
    }

    function placeSuspect(x, z) {
      suspect.position.set(x, terrainHeight(x, z), z);
    }
    placeSuspect(-90, -68);

    function tryTag() {
      const d = camera.position.distanceTo(suspect.position);
      if (d > 2.8) return;
      if (suspectState.mode === 'tag' && !suspectState.visible) return;
      suspectState.catches += 1;
      ui.score.textContent = String(suspectState.catches);
      ui.msg.textContent = 'Tagged! Suspect relocated.';
      suspectState.wp = (suspectState.wp + 4) % suspectState.path.length;
      const [rx, rz] = suspectState.path[suspectState.wp];
      placeSuspect(rx, rz);
      if (suspectState.catches >= 3) {
        const sec = ((performance.now() - suspectState.started) / 1000).toFixed(1);
        ui.finishText.textContent = `You secured 3 catches in ${sec}s (${suspectState.mode === 'chase' ? 'Chase' : 'Hide-and-seek'} mode).`;
        ui.finish.style.display = 'grid';
        document.exitPointerLock();
      }
    }

    const clock = new THREE.Clock();
    function animate() {
      requestAnimationFrame(animate);
      const dt = Math.min(clock.getDelta(), .05);
      const t = clock.elapsedTime;

      camera.rotation.order = 'YXZ'; camera.rotation.y = player.yaw; camera.rotation.x = player.pitch;
      move.set(0,0,0);
      if (state.forward) move.z -= 1;
      if (state.back) move.z += 1;
      if (state.left) move.x -= 1;
      if (state.right) move.x += 1;
      if (move.lengthSq() > 0) move.normalize();

      const accel = baseMove * (state.canControl ? 1 : 0);
      velocity.x = THREE.MathUtils.damp(velocity.x, move.x * accel, 10, dt);
      velocity.z = THREE.MathUtils.damp(velocity.z, move.z * accel, 10, dt);

      tempF.set(0,0,-1).applyAxisAngle(new THREE.Vector3(0,1,0), player.yaw);
      tempR.set(1,0,0).applyAxisAngle(new THREE.Vector3(0,1,0), player.yaw);
      player.x += tempF.x * velocity.z * dt + tempR.x * velocity.x * dt;
      player.z += tempF.z * velocity.z * dt + tempR.z * velocity.x * dt;
      ({x:player.x, z:player.z} = resolveCollide(player.x, player.z));
      player.x = THREE.MathUtils.clamp(player.x, worldMin, 84);
      player.z = THREE.MathUtils.clamp(player.z, worldMin, worldMax);
      camera.position.set(player.x, terrainHeight(player.x, player.z) + eyeHeight, player.z);

      const toP = new THREE.Vector3(camera.position.x - suspect.position.x, 0, camera.position.z - suspect.position.z);
      const dist = toP.length();
      const base = suspectState.speedBase;
      let rbFactor = 1;
      let rbLabel = 'neutral';
      if (dist > 42) { rbFactor = .84; rbLabel = 'assist player'; }
      else if (dist < 14) { rbFactor = 1.2; rbLabel = 'suspect evasive'; }

      suspectState.hideTimer -= dt;
      if (suspectState.mode === 'tag') {
        if (suspectState.hideTimer <= 0) {
          suspectState.visible = !suspectState.visible;
          suspectState.hideTimer = suspectState.visible ? 10 : 6;
          if (!suspectState.visible) {
            const hs = hideSpots[(Math.random() * hideSpots.length) | 0];
            placeSuspect(hs.x, hs.z);
          }
        }
      } else {
        suspectState.visible = true;
      }
      suspect.visible = suspectState.visible;

      const wp = suspectState.path[suspectState.wp];
      const target = new THREE.Vector3(wp[0], terrainHeight(wp[0], wp[1]), wp[1]);
      const dir = target.clone().sub(suspect.position); dir.y = 0;
      if (dir.length() < 2.5) suspectState.wp = (suspectState.wp + 1) % suspectState.path.length;
      dir.normalize();
      if (dist < 18) {
        const away = suspect.position.clone().sub(camera.position); away.y = 0; away.normalize();
        dir.lerp(away, .55 + Math.sin(t * 5.5) * .15).normalize();
      }
      const sSpeed = base * rbFactor * (suspectState.visible ? 1 : 0.65);
      suspect.position.x += dir.x * sSpeed * dt;
      suspect.position.z += dir.z * sSpeed * dt;
      suspect.position.y = terrainHeight(suspect.position.x, suspect.position.z);
      suspect.rotation.y = Math.atan2(dir.x, dir.z);

      // ambient animations
      npcs.forEach((npc, i) => {
        if (!npc.mesh.visible) return;
        npc.mesh.position.y = npc.baseY + Math.sin(t * 1.2 + npc.phase) * 0.02;
        npc.mesh.rotation.y = Math.sin(t * .45 + i) * 0.35;
      });
      animatedProps.forEach((obj, i) => {
        if (!obj.visible) return;
        obj.position.y += Math.sin((t + i) * 1.6) * 0.0009;
        obj.rotation.y += dt * (0.3 + i * 0.04);
      });

      ui.dist.textContent = dist.toFixed(1);
      ui.rb.textContent = rbLabel;
      ui.time.textContent = ((performance.now() - suspectState.started) / 1000).toFixed(1);

      if (suspectState.mode === 'chase' && dist < 2.2) tryTag(false);
      if (suspectState.mode === 'tag' && dist < 3.5 && suspectState.visible) ui.msg.textContent = 'Press E to tag suspect!';

      const day = Math.sin(t * .04) * .5 + .5;
      hemi.intensity = .35 + day * .9; sun.intensity = .25 + day * 1.0;
      sun.position.set(Math.cos(t * .04) * 120, 20 + day * 130, Math.sin(t * .04) * 90);
      sunGlow.position.copy(sun.position).multiplyScalar(.9);
      water.material.color.set(day > .5 ? 0x2f86bc : 0x1f4f7d);
      clouds.forEach((c, i) => { c.position.x += dt * (0.8 + i * .02); if (c.position.x > 200) c.position.x = -200; });

      updateCulling(camera.position.x, camera.position.z);
      renderer.render(scene, camera);
    }
    animate();

    addEventListener('resize', () => {
      camera.aspect = innerWidth / innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(innerWidth, innerHeight);
    });

    refreshAssetStatus();
    window.__assetLog = assetLog;
    window.__suspectVisualLoaded = () => suspectVisualLoaded;
  </script>
</body>
</html>
