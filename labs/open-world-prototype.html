<!doctype html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Mediterranean Chase Prototype</title>
  <style>
    html, body { margin: 0; height: 100%; overflow: hidden; background: #0d1f35; color: #eaf2ff; font-family: Inter, system-ui, sans-serif; }
    #overlay, #finish {
      position: fixed; inset: 0; display: grid; place-items: center; z-index: 20;
      background: linear-gradient(rgba(9,16,33,.72), rgba(9,16,33,.72));
      backdrop-filter: blur(2px);
    }
    #finish { display: none; z-index: 25; }
    #overlay::before {
      content: "";
      position: absolute;
      inset: 0;
      background-image:
        linear-gradient(rgba(7,15,28,.55), rgba(7,15,28,.72)),
        url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 1200 700'%3E%3Cdefs%3E%3ClinearGradient id='sky' x1='0' y1='0' x2='0' y2='1'%3E%3Cstop offset='0' stop-color='%2387c5ff'/%3E%3Cstop offset='1' stop-color='%23ffd4a1'/%3E%3C/linearGradient%3E%3C/defs%3E%3Crect width='1200' height='700' fill='url(%23sky)'/%3E%3Cpath d='M0 430 L180 350 L300 390 L460 300 L620 360 L760 300 L960 360 L1200 280 L1200 700 L0 700 Z' fill='%23c8b089' opacity='.86'/%3E%3Crect y='498' width='1200' height='202' fill='%232f84b6' opacity='.84'/%3E%3Cpath d='M105 470 h112 v108 h-112zM250 444 h135 v130 h-135zM426 424 h150 v156 h-150zM618 456 h122 v118 h-122zM792 410 h156 v166 h-156z' fill='%23f1dfbf' opacity='.93'/%3E%3Cpath d='M95 470 h132 l-62 -54 h-58zM240 444 h155 l-78 -52 h-74zM414 424 h172 l-84 -64 h-74zM612 456 h134 l-68 -46 h-60zM782 410 h174 l-86 -68 h-78z' fill='%239f4b35'/%3E%3C/svg%3E");
      background-size: cover;
      background-position: center;
      z-index: -1;
      pointer-events: none;
    }
    .card {
      width: min(720px, calc(100vw - 32px)); border-radius: 14px; padding: 18px 20px;
      border: 1px solid rgba(148,163,184,.4); background: rgba(9,16,33,.9);
      box-shadow: 0 20px 48px rgba(0,0,0,.34);
    }
    button, select {
      margin-top: 12px; border: 0; border-radius: 9px; padding: 10px 14px; font-weight: 700;
      color: white; background: #2b79ff;
    }
    select { background: #1f3f73; }
    #hud {
      position: fixed; top: 10px; left: 10px; z-index: 10; min-width: 380px;
      border-radius: 10px; padding: 10px 12px; border: 1px solid rgba(148,163,184,.36);
      background: rgba(9,16,33,.74); font-size: 13px; line-height: 1.35;
    }
    #msg { color: #a6f2c4; min-height: 18px; margin-top: 4px; }
    #crosshair { position: fixed; left: 50%; top: 50%; width: 12px; height: 12px; margin-left: -6px; margin-top: -6px; pointer-events: none; z-index: 9; }
    #crosshair::before, #crosshair::after { content:""; position:absolute; background:#f4fbff; }
    #crosshair::before { left:0; top:5px; width:12px; height:2px; }
    #crosshair::after { left:5px; top:0; width:2px; height:12px; }
    #touchControls {
      position: fixed; inset: 0; z-index: 15; pointer-events: none; display: none;
    }
    #touchControls.active { display: block; }
    #movePad {
      position: absolute; left: 14px; bottom: 14px; width: 132px; height: 132px; border-radius: 50%;
      border: 1px solid rgba(220,235,255,.28); background: rgba(12,20,38,.24); pointer-events: auto;
      touch-action: none;
    }
    #moveKnob {
      position: absolute; left: 46px; top: 46px; width: 40px; height: 40px; border-radius: 50%;
      background: rgba(188,216,255,.78); border: 1px solid rgba(255,255,255,.72);
    }
    #lookArea {
      position: absolute; right: 0; top: 18%; width: 58%; height: 64%;
      pointer-events: auto; touch-action: none;
    }
    #touchControls.look-left #lookArea {
      left: 0;
      right: auto;
    }
    #actionBtn {
      position: absolute; right: 16px; bottom: 20px; width: 68px; height: 68px; border-radius: 50%;
      border: 1px solid rgba(180,220,255,.7); background: rgba(43,121,255,.78); color: #fff;
      font-weight: 800; font-size: 22px; pointer-events: auto; touch-action: none;
      display: grid; place-items: center;
    }
    #recenterBtn {
      position: absolute; right: 16px; bottom: 98px; min-width: 96px; height: 42px; border-radius: 999px;
      border: 1px solid rgba(180,220,255,.62); background: rgba(12,32,64,.72); color: #fff;
      font-weight: 700; font-size: 13px; pointer-events: auto; touch-action: none;
      display: grid; place-items: center;
    }
    #swapSideBtn {
      position: absolute; right: 16px; bottom: 146px; min-width: 112px; height: 42px; border-radius: 999px;
      border: 1px solid rgba(180,220,255,.62); background: rgba(12,32,64,.72); color: #fff;
      font-weight: 700; font-size: 13px; pointer-events: auto; touch-action: none;
      display: grid; place-items: center;
    }
    #resetTouchUiBtn {
      position: absolute; right: 16px; bottom: 194px; min-width: 136px; height: 42px; border-radius: 999px;
      border: 1px solid rgba(180,220,255,.62); background: rgba(12,32,64,.72); color: #fff;
      font-weight: 700; font-size: 13px; pointer-events: auto; touch-action: none;
      display: grid; place-items: center;
    }
    #hapticToggleBtn {
      position: absolute; right: 16px; bottom: 242px; min-width: 124px; height: 42px; border-radius: 999px;
      border: 1px solid rgba(180,220,255,.62); background: rgba(12,32,64,.72); color: #fff;
      font-weight: 700; font-size: 13px; pointer-events: auto; touch-action: none;
      display: grid; place-items: center;
    }
    #compactToggleBtn {
      position: absolute; right: 16px; bottom: 290px; min-width: 124px; height: 42px; border-radius: 999px;
      border: 1px solid rgba(180,220,255,.62); background: rgba(12,32,64,.72); color: #fff;
      font-weight: 700; font-size: 13px; pointer-events: auto; touch-action: none;
      display: grid; place-items: center;
    }
    #touchOpacityWrap {
      position: absolute; right: 16px; bottom: 338px; width: 124px;
      border-radius: 10px; border: 1px solid rgba(180,220,255,.45);
      background: rgba(12,32,64,.62); padding: 6px 8px;
      pointer-events: auto;
    }
    #touchOpacityLabel {
      display: block; font-size: 11px; font-weight: 700; margin-bottom: 4px;
      color: rgba(234,242,255,.92);
    }
    #touchOpacityRange {
      width: 100%; margin: 0; touch-action: none;
    }
    #touchControls.look-left #hapticToggleBtn,
    #touchControls.look-left #compactToggleBtn,
    #touchControls.look-left #touchOpacityWrap,
    #touchControls.look-left #resetTouchUiBtn,
    #touchControls.look-left #swapSideBtn,
    #touchControls.look-left #recenterBtn,
    #touchControls.look-left #actionBtn {
      left: 16px;
      right: auto;
    }
    #touchControls.compact #movePad {
      left: 10px; bottom: 10px; width: 108px; height: 108px;
    }
    #touchControls.compact #moveKnob {
      left: 38px; top: 38px; width: 32px; height: 32px;
    }
    #touchControls.compact #actionBtn {
      right: 12px; bottom: 14px; width: 56px; height: 56px; font-size: 18px;
    }
    #touchControls.compact #recenterBtn,
    #touchControls.compact #swapSideBtn,
    #touchControls.compact #resetTouchUiBtn,
    #touchControls.compact #hapticToggleBtn,
    #touchControls.compact #compactToggleBtn {
      right: 12px; height: 36px; min-width: 96px; font-size: 12px;
    }
    #touchControls.compact #recenterBtn { bottom: 76px; }
    #touchControls.compact #swapSideBtn { bottom: 118px; min-width: 104px; }
    #touchControls.compact #resetTouchUiBtn { bottom: 160px; min-width: 122px; }
    #touchControls.compact #hapticToggleBtn { bottom: 202px; min-width: 112px; }
    #touchControls.compact #compactToggleBtn { bottom: 244px; min-width: 122px; }
    #touchControls.compact #touchOpacityWrap {
      right: 12px; bottom: 286px; width: 112px; padding: 5px 7px;
    }
  </style>
</head>
<body>
  <div id="hud">
    <div><strong>Mode:</strong> <span id="modeLabel">Chase</span> · <strong>Quality:</strong> <span id="qLabel">High</span></div>
    <div><strong>Distance:</strong> <span id="dist">--</span>m · <strong>Rubber-band:</strong> <span id="rb">neutral</span></div>
    <div><strong>Catches:</strong> <span id="score">0</span> · <strong>Time:</strong> <span id="time">0.0</span>s</div>
    <div><strong>Assets:</strong> <span id="assetStatus">loading...</span></div>
    <div id="controlsHelp">WASD move · Mouse look · E interact/tag · Esc unlock</div>
    <div id="msg">Track the suspect through the old city alleys.</div>
  </div>
  <div id="crosshair"></div>
  <div id="touchControls" aria-label="Touch controls">
    <div id="movePad" aria-label="Move joystick"><div id="moveKnob"></div></div>
    <div id="lookArea" aria-label="Look area"></div>
    <div id="touchOpacityWrap" aria-label="Touch controls opacity">
      <label id="touchOpacityLabel" for="touchOpacityRange">Control Opacity: 85%</label>
      <input id="touchOpacityRange" type="range" min="30" max="100" step="5" value="85" aria-label="Control Opacity" />
    </div>
    <button id="hapticToggleBtn" aria-label="Toggle touch haptics">Haptic: On</button>
    <button id="compactToggleBtn" aria-label="Toggle compact touch controls">Compact: Off</button>
    <button id="resetTouchUiBtn" aria-label="Reset touch UI">Reset Touch UI</button>
    <button id="swapSideBtn" aria-label="Swap look side">Swap Side</button>
    <button id="recenterBtn" aria-label="Recenter camera">Recenter</button>
    <button id="actionBtn" aria-label="Interact">E</button>
  </div>

  <div id="overlay">
    <div class="card">
      <h2 style="margin:0 0 10px;">Mediterranean City Chase Prototype</h2>
      <p style="margin:0 0 8px;">Catch the fleeing spy across steep streets, plazas, and harbor lanes. The suspect adapts speed based on your performance (rubber-banding).</p>
      <label>Game mode:
        <select id="modeSel">
          <option value="chase">Chase (core)</option>
          <option value="tag">Hide-and-seek / Tag</option>
        </select>
      </label>
      <label style="margin-left:10px;">Performance:
        <select id="qualitySel">
          <option value="high">High</option>
          <option value="low">Low</option>
        </select>
      </label>
      <button id="startBtn">Start</button>
    </div>
  </div>

  <div id="finish">
    <div class="card">
      <h2 style="margin:0 0 8px;color:#97f4b8;">Catch Confirmed ✅</h2>
      <p id="finishText" style="margin:0 0 8px;"></p>
      <button id="againBtn">Play Again</button>
    </div>
  </div>

  <script type="module">
    import * as THREE from 'https://cdn.jsdelivr.net/npm/three@0.161/build/three.module.js';

    const scene = new THREE.Scene();
    scene.fog = new THREE.Fog(0x9ec9ff, 65, 300);

    const lowPowerDevice = (navigator.deviceMemory && navigator.deviceMemory <= 4) || /Mobi|Android|iPhone/i.test(navigator.userAgent);
    const touchCapable = matchMedia('(pointer: coarse)').matches || navigator.maxTouchPoints > 0 || ('ontouchstart' in window);
    function makePatternTexture(draw, size = 256) {
      const can = document.createElement('canvas');
      can.width = can.height = size;
      const c = can.getContext('2d');
      draw(c, size);
      const tex = new THREE.CanvasTexture(can);
      tex.wrapS = tex.wrapT = THREE.RepeatWrapping;
      return tex;
    }

    const stuccoTex = makePatternTexture((c, s) => {
      c.fillStyle = '#d8bf97'; c.fillRect(0, 0, s, s);
      for (let i = 0; i < 1200; i++) {
        const a = Math.random() * 0.18;
        c.fillStyle = `rgba(120,90,60,${a})`;
        const x = Math.random() * s, y = Math.random() * s, r = Math.random() * 2.2;
        c.fillRect(x, y, r, r);
      }
    });
    stuccoTex.repeat.set(2.2, 2.2);

    const roofTileTex = makePatternTexture((c, s) => {
      c.fillStyle = '#994833'; c.fillRect(0, 0, s, s);
      c.strokeStyle = 'rgba(255,220,180,0.2)'; c.lineWidth = 2;
      for (let y = 8; y < s; y += 14) {
        c.beginPath(); c.moveTo(0, y); c.lineTo(s, y); c.stroke();
      }
      for (let x = 6; x < s; x += 22) {
        c.beginPath(); c.moveTo(x, 0); c.lineTo(x - 7, s); c.stroke();
      }
    });
    roofTileTex.repeat.set(2.4, 2.4);

    const cobbleTex = makePatternTexture((c, s) => {
      c.fillStyle = '#baa888'; c.fillRect(0, 0, s, s);
      c.strokeStyle = 'rgba(85,70,50,0.28)'; c.lineWidth = 1;
      const step = 24;
      for (let y = 0; y <= s; y += step) {
        for (let x = 0; x <= s; x += step) {
          const ox = ((y / step) % 2) ? 8 : 0;
          c.strokeRect(x + ox, y, step - 3, step - 3);
        }
      }
    });
    cobbleTex.repeat.set(10, 10);

    const sandTex = makePatternTexture((c, s) => {
      c.fillStyle = '#cdb58d'; c.fillRect(0, 0, s, s);
      for (let i = 0; i < 1800; i++) {
        const v = 170 + (Math.random() * 60) | 0;
        c.fillStyle = `rgba(${v},${v-22},${v-45},0.22)`;
        c.fillRect(Math.random() * s, Math.random() * s, 1, 1);
      }
    });
    sandTex.repeat.set(18, 18);

    const waterTex = makePatternTexture((c, s) => {
      const g = c.createLinearGradient(0, 0, s, s);
      g.addColorStop(0, '#58a2d2'); g.addColorStop(1, '#2a6f9e');
      c.fillStyle = g; c.fillRect(0, 0, s, s);
      c.strokeStyle = 'rgba(235,248,255,0.15)';
      for (let i = 0; i < 60; i++) {
        const y = (i / 60) * s;
        c.beginPath(); c.moveTo(0, y); c.quadraticCurveTo(s * .4, y + 4, s, y - 2); c.stroke();
      }
    });
    waterTex.repeat.set(4, 12);

    const camera = new THREE.PerspectiveCamera(75, innerWidth / innerHeight, 0.1, 900);
    const renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setSize(innerWidth, innerHeight);
    renderer.setPixelRatio(Math.min(devicePixelRatio, 2));
    renderer.shadowMap.enabled = true;
    renderer.shadowMap.type = THREE.PCFSoftShadowMap;
    document.body.appendChild(renderer.domElement);

    const hemi = new THREE.HemisphereLight(0xd8ebff, 0x3a2e23, 0.95);
    const sun = new THREE.DirectionalLight(0xffffff, 1.1);
    sun.position.set(80, 130, 40);
    sun.castShadow = true;
    sun.shadow.mapSize.set(1024, 1024);
    sun.shadow.camera.left = -180;
    sun.shadow.camera.right = 180;
    sun.shadow.camera.top = 180;
    sun.shadow.camera.bottom = -180;
    scene.add(hemi, sun);

    const sky = new THREE.Mesh(
      new THREE.SphereGeometry(700, 32, 16),
      new THREE.ShaderMaterial({
        side: THREE.BackSide,
        uniforms: {
          top: { value: new THREE.Color(0x78b8ff) },
          bottom: { value: new THREE.Color(0xf1cfa6) }
        },
        vertexShader: `varying vec3 vPos; void main(){ vPos=position; gl_Position=projectionMatrix*modelViewMatrix*vec4(position,1.0); }`,
        fragmentShader: `uniform vec3 top; uniform vec3 bottom; varying vec3 vPos; void main(){ float h=normalize(vPos).y*0.5+0.5; gl_FragColor=vec4(mix(bottom,top,smoothstep(0.0,1.0,h)),1.0);} `
      })
    );
    scene.add(sky);

    const sunGlow = new THREE.Sprite(new THREE.SpriteMaterial({ color: 0xffe4a0, transparent: true, opacity: 0.5 }));
    sunGlow.scale.set(34, 34, 1);
    sunGlow.position.set(130, 120, -80);
    scene.add(sunGlow);

    const cloudMat = new THREE.MeshBasicMaterial({ color: 0xffffff, transparent: true, opacity: 0.16 });
    const clouds = [];
    for (let i = 0; i < 22; i++) {
      const c = new THREE.Mesh(new THREE.PlaneGeometry(24 + Math.random() * 32, 8 + Math.random() * 6), cloudMat);
      c.position.set(-180 + Math.random() * 360, 62 + Math.random() * 36, -180 + Math.random() * 360);
      c.rotation.x = -Math.PI / 2;
      scene.add(c); clouds.push(c);
    }

    const worldMin = -200, worldMax = 200, eyeHeight = 1.7;
    function terrainHeight(x, z) {
      const h = Math.sin(x * 0.022) * 3.4 + Math.cos(z * 0.02) * 2.6
        + Math.exp(-((x + 44) ** 2 + (z + 64) ** 2) / 11800) * 12
        + Math.exp(-((x - 88) ** 2 + (z - 28) ** 2) / 9200) * 10;
      if (x > 68) return THREE.MathUtils.lerp(h, -2.9, THREE.MathUtils.smoothstep(x, 68, 128));
      return h;
    }

    const groundGeo = new THREE.PlaneGeometry(450, 450, 120, 120);
    const pos = groundGeo.attributes.position;
    for (let i = 0; i < pos.count; i++) pos.setZ(i, terrainHeight(pos.getX(i), pos.getY(i)));
    groundGeo.computeVertexNormals();
    const ground = new THREE.Mesh(groundGeo, new THREE.MeshStandardMaterial({ color: 0xcab28c, roughness: .98, map: sandTex }));
    ground.rotation.x = -Math.PI / 2;
    ground.receiveShadow = true;
    scene.add(ground);

    const water = new THREE.Mesh(new THREE.PlaneGeometry(190, 460), new THREE.MeshStandardMaterial({ color: 0x2f86bc, roughness: .22, transparent: true, opacity: .9, map: waterTex }));
    water.rotation.x = -Math.PI / 2; water.position.set(132, -3.2, 0); scene.add(water);

    const buildingColliders = [];
    const staticDecor = [];
    const npcs = [];
    const animatedProps = [];

    function pushDecor(o) {
      staticDecor.push(o);
      o.traverse?.((n) => { if (n.isMesh) { n.castShadow = true; n.receiveShadow = true; } });
      scene.add(o);
    }

    const bColors = [0xf2dfbd, 0xe4cda5, 0xd8be95, 0xf4e5ca, 0xe9d7b5, 0xf7e6d0];
    const roofColors = [0x9d4730, 0xb35e3e, 0x8a3a2b, 0xa9533a];
    for (let i = 0; i < 250; i++) {
      const x = -170 + Math.random() * 240, z = -170 + Math.random() * 340;
      if (x > 72 || terrainHeight(x, z) < -0.8) continue;
      const y = terrainHeight(x, z);
      const w = 4 + Math.random() * 5.2, d = 4 + Math.random() * 5, h = 5 + Math.random() * 16;
      const g = new THREE.Group();
      const body = new THREE.Mesh(new THREE.BoxGeometry(w, h, d), new THREE.MeshStandardMaterial({ color: bColors[(Math.random() * bColors.length) | 0], roughness: .86, map: stuccoTex }));
      body.position.y = h / 2;
      const roof = new THREE.Mesh(new THREE.ConeGeometry(Math.max(w, d) * .64, Math.max(.8, h * .12), 4), new THREE.MeshStandardMaterial({ color: roofColors[(Math.random() * roofColors.length) | 0], roughness: .92, map: roofTileTex }));
      roof.rotation.y = Math.PI * 0.25; roof.position.y = h + 0.55;
      g.add(body, roof);
      if (Math.random() < .6) {
        const arch = new THREE.Mesh(new THREE.TorusGeometry(0.6, 0.15, 8, 16, Math.PI), new THREE.MeshStandardMaterial({ color: 0xcfb892, roughness: .9 }));
        arch.rotation.z = Math.PI; arch.position.set(0, 1.3, d * 0.51); g.add(arch);
      }
      g.position.set(x, y, z);
      pushDecor(g);
      buildingColliders.push({ x, z, r: Math.max(w, d) * .56 + .55 });
    }

    // streets
    const roadMat = new THREE.MeshStandardMaterial({ color: 0xb6a98d, roughness: 0.96, map: cobbleTex });
    function addPath(x1, z1, x2, z2, width = 4.2, steps = 22) {
      for (let i = 0; i <= steps; i++) {
        const t = i / steps, x = THREE.MathUtils.lerp(x1, x2, t), z = THREE.MathUtils.lerp(z1, z2, t);
        const tile = new THREE.Mesh(new THREE.BoxGeometry(width, .2, width * .84), roadMat);
        tile.position.set(x, terrainHeight(x, z) + .05, z);
        tile.rotation.y = Math.atan2(x2 - x1, z2 - z1);
        pushDecor(tile);
      }
    }
    [[-150,-110,-90,-42],[-90,-42,-20,-6],[-20,-6,58,18],[-86,72,-6,40],[-6,40,54,78],[-26,96,34,126],[-8,-92,44,-56],[-60,120,16,146],[-124,18,-40,26]].forEach(p=>addPath(...p));

    // street furniture
    const lampMat = new THREE.MeshStandardMaterial({ color: 0x2b3242, roughness: .65, metalness: .55 });
    const benchMat = new THREE.MeshStandardMaterial({ color: 0x81593b, roughness: .85 });
    const planterMat = new THREE.MeshStandardMaterial({ color: 0x9c8f7b, roughness: .95 });

    function addLamp(x, z) {
      const y = terrainHeight(x, z);
      const g = new THREE.Group();
      const pole = new THREE.Mesh(new THREE.CylinderGeometry(.13, .18, 4.4, 8), lampMat);
      pole.position.y = 2.2;
      const arm = new THREE.Mesh(new THREE.BoxGeometry(1.2, .13, .13), lampMat);
      arm.position.set(.54, 4.1, 0);
      const bulb = new THREE.Mesh(new THREE.SphereGeometry(.16, 8, 8), new THREE.MeshStandardMaterial({ color: 0xffe8a1, emissive: 0xffcc66, emissiveIntensity: .3 }));
      bulb.position.set(1.04, 3.96, 0);
      g.add(pole, arm, bulb);
      g.position.set(x, y, z);
      pushDecor(g);
    }

    function addBench(x, z, rot = 0) {
      const y = terrainHeight(x, z);
      const g = new THREE.Group();
      const seat = new THREE.Mesh(new THREE.BoxGeometry(1.9, .16, .55), benchMat);
      seat.position.y = .6;
      const back = new THREE.Mesh(new THREE.BoxGeometry(1.9, .5, .14), benchMat);
      back.position.set(0, .95, -.2);
      const legMat = new THREE.MeshStandardMaterial({ color: 0x2c2a2a, roughness: .8 });
      [-.8, .8].forEach((lx) => {
        const leg1 = new THREE.Mesh(new THREE.BoxGeometry(.12, .6, .12), legMat);
        leg1.position.set(lx, .3, .18);
        const leg2 = leg1.clone(); leg2.position.z = -.18;
        g.add(leg1, leg2);
      });
      g.add(seat, back);
      g.position.set(x, y + .02, z);
      g.rotation.y = rot;
      pushDecor(g);
    }

    function addPlanter(x, z) {
      const y = terrainHeight(x, z);
      const g = new THREE.Group();
      const pot = new THREE.Mesh(new THREE.CylinderGeometry(.62, .7, .72, 10), planterMat);
      pot.position.y = .36;
      const trunk = new THREE.Mesh(new THREE.CylinderGeometry(.08, .1, .7, 7), new THREE.MeshStandardMaterial({ color: 0x6d4a2f, roughness: .95 }));
      trunk.position.y = .9;
      const crown = new THREE.Mesh(new THREE.SphereGeometry(.55, 9, 8), new THREE.MeshStandardMaterial({ color: 0x4f8c4f, roughness: .9 }));
      crown.position.y = 1.5;
      g.add(pot, trunk, crown);
      g.position.set(x, y, z);
      pushDecor(g);
    }

    for (let i = -130; i <= 48; i += 28) addLamp(i, -44);
    for (let i = -90; i <= 30; i += 24) addBench(i, 42, Math.PI * 0.1);
    [[-64,40],[-32,38],[12,66],[26,92],[-20,-20],[38,26]].forEach(([x,z]) => addPlanter(x, z));

    // harbor details
    function addDock(x, z, w = 10, d = 3) {
      const y = -2.6;
      const deck = new THREE.Mesh(new THREE.BoxGeometry(w, .4, d), new THREE.MeshStandardMaterial({ color: 0x8d6c49, roughness: .93 }));
      deck.position.set(x, y, z);
      pushDecor(deck);
      for (let i = -1; i <= 1; i += 2) {
        const post = new THREE.Mesh(new THREE.CylinderGeometry(.22, .24, 2.2, 8), new THREE.MeshStandardMaterial({ color: 0x544437, roughness: .95 }));
        post.position.set(x + i * (w * .4), y - 1, z + d * .35);
        pushDecor(post);
      }
    }

    function addBoatFallback(x, z, scale = 1) {
      const g = new THREE.Group();
      const hull = new THREE.Mesh(new THREE.BoxGeometry(4.6 * scale, .8 * scale, 1.6 * scale), new THREE.MeshStandardMaterial({ color: 0xc54f35, roughness: .7 }));
      const cabin = new THREE.Mesh(new THREE.BoxGeometry(1.5 * scale, .8 * scale, 1.2 * scale), new THREE.MeshStandardMaterial({ color: 0xf3e8d8, roughness: .86 }));
      cabin.position.y = .75 * scale;
      g.add(hull, cabin);
      g.position.set(x, -2.3, z);
      pushDecor(g);
      return g;
    }

    [[90, -100], [98, -28], [104, 30], [114, 86]].forEach(([x,z]) => addDock(x, z, 10 + Math.random() * 4, 2.8 + Math.random() * .8));
    const fallbackBoats = [[122,-74],[128,-10],[136,56]].map(([x,z]) => addBoatFallback(x, z, 0.9 + Math.random() * .3));

    // asset loader + fallbacks
    let loader = null;
    try {
      const mod = await import('https://esm.sh/three@0.161/examples/jsm/loaders/GLTFLoader.js');
      loader = new mod.GLTFLoader();
    } catch (err) {
      console.warn('GLTFLoader unavailable; continuing with primitive fallback assets.', err);
    }

    const suspect = new THREE.Group(); scene.add(suspect);
    let suspectVisualLoaded = false;
    const assetLog = [];
    const loadedAssets = { ok: 0, fail: 0 };

    const ui = {
      overlay: document.getElementById('overlay'),
      finish: document.getElementById('finish'),
      finishText: document.getElementById('finishText'),
      modeSel: document.getElementById('modeSel'),
      qualitySel: document.getElementById('qualitySel'),
      modeLabel: document.getElementById('modeLabel'),
      qLabel: document.getElementById('qLabel'),
      dist: document.getElementById('dist'),
      rb: document.getElementById('rb'),
      score: document.getElementById('score'),
      time: document.getElementById('time'),
      msg: document.getElementById('msg'),
      assetStatus: document.getElementById('assetStatus'),
      controlsHelp: document.getElementById('controlsHelp'),
      touchControls: document.getElementById('touchControls'),
      movePad: document.getElementById('movePad'),
      moveKnob: document.getElementById('moveKnob'),
      lookArea: document.getElementById('lookArea'),
      touchOpacityLabel: document.getElementById('touchOpacityLabel'),
      touchOpacityRange: document.getElementById('touchOpacityRange'),
      hapticToggleBtn: document.getElementById('hapticToggleBtn'),
      compactToggleBtn: document.getElementById('compactToggleBtn'),
      resetTouchUiBtn: document.getElementById('resetTouchUiBtn'),
      swapSideBtn: document.getElementById('swapSideBtn'),
      recenterBtn: document.getElementById('recenterBtn'),
      actionBtn: document.getElementById('actionBtn')
    };

    function refreshAssetStatus() {
      ui.assetStatus.textContent = `${loadedAssets.ok} loaded / ${loadedAssets.fail} fallback`;
    }

    const TOUCH_LOOK_SIDE_STORAGE_KEY = 'openWorldCity.touchLookSide';
    const TOUCH_HAPTIC_STORAGE_KEY = 'openWorldCity.touchHapticEnabled';
    const TOUCH_CONTROLS_OPACITY_STORAGE_KEY = 'openWorldCity.touchControlsOpacity';
    const TOUCH_COMPACT_STORAGE_KEY = 'openWorldCity.touchCompactControls';
    const DEFAULT_TOUCH_CONTROLS_OPACITY = 85;
    const touchInput = { moveX: 0, moveY: 0, lookActive: false, lookId: null, lookX: 0, lookY: 0, lookSide: 'right', hapticEnabled: touchCapable, compactEnabled: false };
    function touchMoveRadius() {
      return touchInput.compactEnabled ? 34 : 42;
    }
    function touchKnobBase() {
      return touchInput.compactEnabled ? 38 : 46;
    }
    function resetMoveKnob() {
      const knobBase = touchKnobBase();
      ui.moveKnob.style.left = `${knobBase}px`;
      ui.moveKnob.style.top = `${knobBase}px`;
      touchInput.moveX = 0;
      touchInput.moveY = 0;
    }
    function recenterCamera() {
      player.yaw = defaultCameraFacing.yaw;
      player.pitch = defaultCameraFacing.pitch;
    }
    function setupTouchControls() {
      if (!touchCapable) return;
      ui.touchControls.classList.add('active');
      ui.controlsHelp.textContent = 'Left thumb: move · Right drag: look · Compact shrinks touch UI · Opacity slider sets control transparency · Swap Side flips look pad · Recenter resets view · Reset Touch UI restores defaults · Haptic toggles vibration · E button: interact/tag';

      function triggerTouchHaptic() {
        if (!touchInput.hapticEnabled || typeof navigator.vibrate !== 'function') return;
        try { navigator.vibrate(10); } catch (_) { /* no-op */ }
      }
      function refreshHapticToggleLabel() {
        ui.hapticToggleBtn.textContent = `Haptic: ${touchInput.hapticEnabled ? 'On' : 'Off'}`;
      }
      function applyCompactMode(enabled) {
        touchInput.compactEnabled = !!enabled;
        ui.touchControls.classList.toggle('compact', touchInput.compactEnabled);
        ui.compactToggleBtn.textContent = `Compact: ${touchInput.compactEnabled ? 'On' : 'Off'}`;
        resetMoveKnob();
      }
      function loadTouchCompactPreference() {
        try {
          return localStorage.getItem(TOUCH_COMPACT_STORAGE_KEY) === 'on';
        } catch (_) {
          return false;
        }
      }
      function saveTouchCompactPreference() {
        try {
          localStorage.setItem(TOUCH_COMPACT_STORAGE_KEY, touchInput.compactEnabled ? 'on' : 'off');
        } catch (_) {
          // ignore storage failures
        }
      }
      function loadTouchHapticPreference() {
        try {
          const saved = localStorage.getItem(TOUCH_HAPTIC_STORAGE_KEY);
          if (saved === 'on') touchInput.hapticEnabled = true;
          if (saved === 'off') touchInput.hapticEnabled = false;
        } catch (_) {
          // ignore storage failures
        }
      }
      function saveTouchHapticPreference() {
        try {
          localStorage.setItem(TOUCH_HAPTIC_STORAGE_KEY, touchInput.hapticEnabled ? 'on' : 'off');
        } catch (_) {
          // ignore storage failures
        }
      }

      function applyTouchControlsOpacity(value) {
        const clamped = THREE.MathUtils.clamp(Number(value) || DEFAULT_TOUCH_CONTROLS_OPACITY, 30, 100);
        ui.touchControls.style.opacity = String(clamped / 100);
        ui.touchOpacityRange.value = String(clamped);
        ui.touchOpacityLabel.textContent = `Control Opacity: ${clamped}%`;
      }
      function loadTouchControlsOpacityPreference() {
        try {
          const saved = Number(localStorage.getItem(TOUCH_CONTROLS_OPACITY_STORAGE_KEY));
          if (Number.isFinite(saved) && saved >= 30 && saved <= 100) return saved;
        } catch (_) {
          // ignore storage failures
        }
        return DEFAULT_TOUCH_CONTROLS_OPACITY;
      }
      function saveTouchControlsOpacityPreference(value) {
        try {
          localStorage.setItem(TOUCH_CONTROLS_OPACITY_STORAGE_KEY, String(value));
        } catch (_) {
          // ignore storage failures
        }
      }

      function loadTouchLookSidePreference() {
        try {
          const savedSide = localStorage.getItem(TOUCH_LOOK_SIDE_STORAGE_KEY);
          if (savedSide === 'left' || savedSide === 'right') touchInput.lookSide = savedSide;
        } catch (_) {
          // ignore storage failures
        }
      }
      function saveTouchLookSidePreference() {
        try {
          localStorage.setItem(TOUCH_LOOK_SIDE_STORAGE_KEY, touchInput.lookSide);
        } catch (_) {
          // ignore storage failures
        }
      }
      function clearTouchLookSidePreference() {
        try {
          localStorage.removeItem(TOUCH_LOOK_SIDE_STORAGE_KEY);
        } catch (_) {
          // ignore storage failures
        }
      }
      function applyLookSide() {
        ui.touchControls.classList.toggle('look-left', touchInput.lookSide === 'left');
      }
      function swapLookSide() {
        touchInput.lookSide = touchInput.lookSide === 'right' ? 'left' : 'right';
        applyLookSide();
        saveTouchLookSidePreference();
      }
      function resetTouchUi() {
        touchInput.lookSide = 'right';
        applyLookSide();
        clearTouchLookSidePreference();
        applyCompactMode(false);
        saveTouchCompactPreference();
        applyTouchControlsOpacity(DEFAULT_TOUCH_CONTROLS_OPACITY);
        saveTouchControlsOpacityPreference(DEFAULT_TOUCH_CONTROLS_OPACITY);
        recenterCamera();
      }
      loadTouchLookSidePreference();
      loadTouchHapticPreference();
      applyCompactMode(loadTouchCompactPreference());
      applyTouchControlsOpacity(loadTouchControlsOpacityPreference());
      applyLookSide();
      refreshHapticToggleLabel();

      let movePointerId = null;
      function updateMoveFromPointer(e) {
        const r = ui.movePad.getBoundingClientRect();
        const cx = r.left + r.width / 2;
        const cy = r.top + r.height / 2;
        let dx = e.clientX - cx;
        let dy = e.clientY - cy;
        const maxR = touchMoveRadius();
        const knobBase = touchKnobBase();
        const len = Math.hypot(dx, dy) || 1;
        if (len > maxR) {
          const s = maxR / len;
          dx *= s; dy *= s;
        }
        touchInput.moveX = dx / maxR;
        touchInput.moveY = dy / maxR;
        ui.moveKnob.style.left = `${knobBase + dx}px`;
        ui.moveKnob.style.top = `${knobBase + dy}px`;
      }

      ui.movePad.addEventListener('pointerdown', (e) => {
        movePointerId = e.pointerId;
        ui.movePad.setPointerCapture(e.pointerId);
        updateMoveFromPointer(e);
      });
      ui.movePad.addEventListener('pointermove', (e) => {
        if (e.pointerId !== movePointerId) return;
        updateMoveFromPointer(e);
      });
      function releaseMove(e) {
        if (e.pointerId !== movePointerId) return;
        movePointerId = null;
        resetMoveKnob();
      }
      ui.movePad.addEventListener('pointerup', releaseMove);
      ui.movePad.addEventListener('pointercancel', releaseMove);

      ui.lookArea.addEventListener('pointerdown', (e) => {
        touchInput.lookActive = true;
        touchInput.lookId = e.pointerId;
        touchInput.lookX = e.clientX;
        touchInput.lookY = e.clientY;
        ui.lookArea.setPointerCapture(e.pointerId);
      });
      ui.lookArea.addEventListener('pointermove', (e) => {
        if (!touchInput.lookActive || e.pointerId !== touchInput.lookId || !state.canControl) return;
        const dx = e.clientX - touchInput.lookX;
        const dy = e.clientY - touchInput.lookY;
        touchInput.lookX = e.clientX;
        touchInput.lookY = e.clientY;
        player.yaw -= dx * .006;
        player.pitch = THREE.MathUtils.clamp(player.pitch - dy * .005, -Math.PI/2 + .02, Math.PI/2 - .02);
      });
      function endLook(e) {
        if (e.pointerId !== touchInput.lookId) return;
        touchInput.lookActive = false;
        touchInput.lookId = null;
      }
      ui.lookArea.addEventListener('pointerup', endLook);
      ui.lookArea.addEventListener('pointercancel', endLook);

      ui.hapticToggleBtn.addEventListener('pointerdown', (e) => {
        e.preventDefault();
        touchInput.hapticEnabled = !touchInput.hapticEnabled;
        refreshHapticToggleLabel();
        saveTouchHapticPreference();
      });

      ui.compactToggleBtn.addEventListener('pointerdown', (e) => {
        e.preventDefault();
        triggerTouchHaptic();
        applyCompactMode(!touchInput.compactEnabled);
        saveTouchCompactPreference();
      });

      ui.touchOpacityRange.addEventListener('input', (e) => {
        const value = Number(e.target.value);
        applyTouchControlsOpacity(value);
        saveTouchControlsOpacityPreference(value);
      });

      ui.resetTouchUiBtn.addEventListener('pointerdown', (e) => {
        e.preventDefault();
        triggerTouchHaptic();
        resetTouchUi();
      });

      ui.swapSideBtn.addEventListener('pointerdown', (e) => {
        e.preventDefault();
        triggerTouchHaptic();
        swapLookSide();
      });

      ui.recenterBtn.addEventListener('pointerdown', (e) => {
        e.preventDefault();
        triggerTouchHaptic();
        recenterCamera();
      });

      ui.actionBtn.addEventListener('pointerdown', (e) => {
        e.preventDefault();
        if (!state.canControl) return;
        triggerTouchHaptic();
        tryTag();
      });
      resetMoveKnob();
    }

    function fallbackSuspect() {
      const body = new THREE.Mesh(new THREE.CapsuleGeometry(.43, 1.2, 4, 8), new THREE.MeshStandardMaterial({ color: 0x2d3f66 }));
      body.position.y = 1.2;
      const head = new THREE.Mesh(new THREE.SphereGeometry(.3, 12, 12), new THREE.MeshStandardMaterial({ color: 0xf0d0b1 }));
      head.position.y = 2.15;
      suspect.add(body, head);
    }
    fallbackSuspect();

    function loadAsset(url, onOk, onFail) {
      if (!loader) {
        loadedAssets.fail += 1;
        assetLog.push(`fallback(loader): ${url}`);
        onFail?.();
        refreshAssetStatus();
        return;
      }
      loader.load(url, (gltf) => {
        loadedAssets.ok += 1;
        assetLog.push(`loaded: ${url}`);
        onOk(gltf.scene);
        refreshAssetStatus();
      }, undefined, () => {
        loadedAssets.fail += 1;
        assetLog.push(`fallback(load-fail): ${url}`);
        onFail?.();
        refreshAssetStatus();
      });
    }

    // main suspect model (improved)
    loadAsset('https://threejs.org/examples/models/gltf/Soldier.glb', (obj) => {
      suspect.clear();
      obj.scale.set(1.2, 1.2, 1.2);
      suspect.add(obj);
      suspectVisualLoaded = true;
    }, fallbackSuspect);

    // city landmark block with fallback tower
    const landmarkAnchor = new THREE.Group();
    landmarkAnchor.position.set(-165, terrainHeight(-165, 145), 145);
    scene.add(landmarkAnchor);
    const fallbackTower = new THREE.Mesh(new THREE.CylinderGeometry(5, 7, 28, 10), new THREE.MeshStandardMaterial({ color: 0xd7c29d, roughness: .88 }));
    fallbackTower.position.y = 14; landmarkAnchor.add(fallbackTower);
    staticDecor.push(landmarkAnchor);

    loadAsset('https://threejs.org/examples/models/gltf/LittlestTokyo.glb', (obj) => {
      landmarkAnchor.clear();
      obj.scale.set(.12, .12, .12); obj.rotation.y = Math.PI * 0.7;
      landmarkAnchor.add(obj);
    });

    // prop set for harbor and plaza
    const propSpawns = [[92,-80],[98,-20],[102,34],[108,92],[-42,46],[-18,74]];
    propSpawns.forEach(([x,z], i) => {
      const anchor = new THREE.Group();
      anchor.position.set(x, x > 80 ? -2.6 : terrainHeight(x, z), z);
      const fb = new THREE.Mesh(new THREE.BoxGeometry(1.8,1.4,1.8), new THREE.MeshStandardMaterial({ color: 0x8a6a4a, roughness:.95 }));
      anchor.add(fb);
      scene.add(anchor);
      staticDecor.push(anchor);
      const url = i % 2 === 0
        ? 'https://threejs.org/examples/models/gltf/DamagedHelmet/glTF-Binary/DamagedHelmet.glb'
        : 'https://cdn.jsdelivr.net/gh/KhronosGroup/glTF-Sample-Models@master/2.0/BoomBox/glTF-Binary/BoomBox.glb';
      loadAsset(url, (obj) => {
        anchor.clear();
        obj.scale.set(1.1, 1.1, 1.1);
        obj.rotation.y = Math.random() * Math.PI;
        anchor.add(obj);
      });
    });

    // additional NPC variety (civilian + birds)
    function spawnNPCFallback(x, z, color = 0x6672a3) {
      const g = new THREE.Group();
      const body = new THREE.Mesh(new THREE.CapsuleGeometry(.32, .9, 4, 8), new THREE.MeshStandardMaterial({ color }));
      const head = new THREE.Mesh(new THREE.SphereGeometry(.22, 10, 10), new THREE.MeshStandardMaterial({ color: 0xf0d0b1 }));
      body.position.y = .95; head.position.y = 1.75;
      g.add(body, head);
      g.position.set(x, terrainHeight(x, z), z);
      scene.add(g);
      npcs.push({ mesh: g, baseY: g.position.y, phase: Math.random() * Math.PI * 2 });
      return g;
    }

    const civilianSpots = [[-74,22],[-38,56],[18,58],[-12,-22]];
    civilianSpots.forEach(([x,z], idx) => {
      const fallback = spawnNPCFallback(x, z, idx % 2 ? 0x9f7c59 : 0x5c6b92);
      loadAsset('https://cdn.jsdelivr.net/gh/KhronosGroup/glTF-Sample-Models@master/2.0/CesiumMan/glTF-Binary/CesiumMan.glb', (obj) => {
        fallback.clear();
        obj.scale.set(1.08, 1.08, 1.08);
        fallback.add(obj);
      });
    });

    const birdSpots = [[120,-94],[134,14],[144,72]];
    birdSpots.forEach(([x,z], idx) => {
      const anchor = new THREE.Group();
      anchor.position.set(x, -2.2 + Math.random() * 0.6, z);
      const fallback = new THREE.Mesh(new THREE.SphereGeometry(.25, 8, 8), new THREE.MeshStandardMaterial({ color: 0xf7f7f7 }));
      anchor.add(fallback);
      scene.add(anchor);
      animatedProps.push(anchor);
      staticDecor.push(anchor);
      const url = idx % 2 === 0
        ? 'https://threejs.org/examples/models/gltf/Parrot.glb'
        : 'https://threejs.org/examples/models/gltf/Flamingo.glb';
      loadAsset(url, (obj) => {
        anchor.clear();
        obj.scale.set(.018, .018, .018);
        anchor.add(obj);
      });
    });

    // boat model swap (harbor detail)
    const boatAnchor = new THREE.Group();
    boatAnchor.position.set(132, -2.35, 26);
    scene.add(boatAnchor);
    staticDecor.push(boatAnchor);
    boatAnchor.add(new THREE.Mesh(new THREE.BoxGeometry(3.8, .9, 1.7), new THREE.MeshStandardMaterial({ color: 0xb94d39, roughness: .8 })));
    loadAsset('https://cdn.jsdelivr.net/gh/KhronosGroup/glTF-Sample-Models@master/2.0/Duck/glTF-Binary/Duck.glb', (obj) => {
      boatAnchor.clear();
      obj.scale.set(0.036, 0.036, 0.036);
      obj.rotation.y = Math.PI * 0.35;
      boatAnchor.add(obj);
    });

    const state = { forward:false, back:false, left:false, right:false, canControl:false };
    const defaultCameraFacing = { yaw: 0, pitch: 0 };
    const player = { x:-8, z:-8, yaw:defaultCameraFacing.yaw, pitch:defaultCameraFacing.pitch };
    const velocity = new THREE.Vector3();
    const move = new THREE.Vector3();
    const tempF = new THREE.Vector3();
    const tempR = new THREE.Vector3();
    const baseMove = 11.2;

    const suspectState = {
      path: [[-98,-78],[-60,-34],[-16,10],[28,42],[58,84],[20,106],[-26,92],[-84,52],[-120,8],[-104,-44]],
      wp: 0,
      speedBase: 7.2,
      mode: 'chase',
      hideTimer: 0,
      visible: true,
      catches: 0,
      started: 0
    };

    const hideSpots = [[-98,78],[-16,82],[36,64],[-72,-18],[18,-56]].map(([x,z]) => new THREE.Vector3(x, terrainHeight(x,z), z));

    let quality = 'high';
    let cullDistance = 175;
    function applyQuality(q) {
      quality = q;
      const low = q === 'low';
      renderer.setPixelRatio(Math.min(devicePixelRatio, low ? 1 : 2));
      renderer.shadowMap.enabled = !low;
      cullDistance = low ? 92 : 175;
      clouds.forEach(c => c.visible = !low);
      npcs.forEach((n, i) => { n.mesh.visible = low ? (i % 2 === 0) : true; });
      fallbackBoats.forEach((b, i) => { b.visible = low ? i === 0 : true; });
      ui.qLabel.textContent = low ? 'Low' : 'High';
    }

    let dragLook = false;
    function lockPointer() {
      if (touchCapable) return;
      if (document.body.requestPointerLock) document.body.requestPointerLock();
    }
    function startRun() {
      suspectState.mode = ui.modeSel.value;
      ui.modeLabel.textContent = suspectState.mode === 'chase' ? 'Chase' : 'Hide & Seek Tag';
      applyQuality(ui.qualitySel.value);
      suspectState.catches = 0; ui.score.textContent = '0'; ui.finish.style.display = 'none';
      suspectState.started = performance.now();
      state.canControl = true;
      ui.overlay.style.display = 'none';
      lockPointer();
      ui.msg.textContent = suspectState.mode === 'chase' ? 'Close in and tag the suspect.' : 'Find, reveal, then tag with E.';
    }
    ui.qualitySel.value = lowPowerDevice ? 'low' : 'high';
    document.getElementById('startBtn').addEventListener('click', startRun);
    document.getElementById('againBtn').addEventListener('click', lockPointer);
    setupTouchControls();

    document.addEventListener('pointerlockchange', () => {
      if (touchCapable) return;
      const locked = document.pointerLockElement === document.body;
      if (locked) {
        state.canControl = true;
        ui.overlay.style.display = 'none';
      } else if (!dragLook) {
        ui.overlay.style.display = state.canControl ? 'none' : 'grid';
      }
    });

    document.addEventListener('mousedown', (e) => {
      if (!state.canControl) return;
      if (document.pointerLockElement !== document.body && e.button === 0) dragLook = true;
    });
    document.addEventListener('mouseup', () => { dragLook = false; });

    document.addEventListener('mousemove', e => {
      if (!state.canControl) return;
      const canLook = document.pointerLockElement === document.body || dragLook;
      if (!canLook) return;
      player.yaw -= e.movementX * .0021;
      player.pitch = THREE.MathUtils.clamp(player.pitch - e.movementY * .0018, -Math.PI/2 + .02, Math.PI/2 - .02);
    });

    document.addEventListener('keydown', e => {
      if (e.code === 'KeyW') state.forward = true;
      if (e.code === 'KeyS') state.back = true;
      if (e.code === 'KeyA') state.left = true;
      if (e.code === 'KeyD') state.right = true;
      if (e.code === 'KeyE') tryTag(true);
    });
    document.addEventListener('keyup', e => {
      if (e.code === 'KeyW') state.forward = false;
      if (e.code === 'KeyS') state.back = false;
      if (e.code === 'KeyA') state.left = false;
      if (e.code === 'KeyD') state.right = false;
    });

    function resolveCollide(nx, nz) {
      let x = nx, z = nz;
      for (const b of buildingColliders) {
        const dx = x - b.x, dz = z - b.z, d2 = dx*dx + dz*dz, r2 = b.r*b.r;
        if (d2 < r2) {
          const d = Math.sqrt(Math.max(1e-4, d2));
          const push = (b.r - d) + .07;
          x += (dx/d)*push; z += (dz/d)*push;
        }
      }
      return {x,z};
    }

    function updateCulling(px, pz) {
      const c2 = cullDistance * cullDistance;
      for (const o of staticDecor) {
        const dx = o.position.x - px, dz = o.position.z - pz;
        o.visible = (dx*dx + dz*dz) < c2;
      }
    }

    function placeSuspect(x, z) {
      suspect.position.set(x, terrainHeight(x, z), z);
    }
    placeSuspect(-90, -68);

    function tryTag() {
      const d = camera.position.distanceTo(suspect.position);
      if (d > 2.8) return;
      if (suspectState.mode === 'tag' && !suspectState.visible) return;
      suspectState.catches += 1;
      ui.score.textContent = String(suspectState.catches);
      ui.msg.textContent = 'Tagged! Suspect relocated.';
      suspectState.wp = (suspectState.wp + 4) % suspectState.path.length;
      const [rx, rz] = suspectState.path[suspectState.wp];
      placeSuspect(rx, rz);
      if (suspectState.catches >= 3) {
        const sec = ((performance.now() - suspectState.started) / 1000).toFixed(1);
        ui.finishText.textContent = `You secured 3 catches in ${sec}s (${suspectState.mode === 'chase' ? 'Chase' : 'Hide-and-seek'} mode).`;
        ui.finish.style.display = 'grid';
        document.exitPointerLock();
      }
    }

    const clock = new THREE.Clock();
    function animate() {
      requestAnimationFrame(animate);
      const dt = Math.min(clock.getDelta(), .05);
      const t = clock.elapsedTime;

      camera.rotation.order = 'YXZ'; camera.rotation.y = player.yaw; camera.rotation.x = player.pitch;
      move.set(0,0,0);
      const keyX = (state.right ? 1 : 0) - (state.left ? 1 : 0);
      const keyZ = (state.back ? 1 : 0) - (state.forward ? 1 : 0);
      move.x = keyX + touchInput.moveX;
      move.z = keyZ + touchInput.moveY;
      if (move.lengthSq() > 1) move.normalize();

      const accel = baseMove * (state.canControl ? 1 : 0);
      velocity.x = THREE.MathUtils.damp(velocity.x, move.x * accel, 10, dt);
      velocity.z = THREE.MathUtils.damp(velocity.z, move.z * accel, 10, dt);

      tempF.set(0,0,-1).applyAxisAngle(new THREE.Vector3(0,1,0), player.yaw);
      tempR.set(1,0,0).applyAxisAngle(new THREE.Vector3(0,1,0), player.yaw);
      player.x += tempF.x * velocity.z * dt + tempR.x * velocity.x * dt;
      player.z += tempF.z * velocity.z * dt + tempR.z * velocity.x * dt;
      ({x:player.x, z:player.z} = resolveCollide(player.x, player.z));
      player.x = THREE.MathUtils.clamp(player.x, worldMin, 84);
      player.z = THREE.MathUtils.clamp(player.z, worldMin, worldMax);
      camera.position.set(player.x, terrainHeight(player.x, player.z) + eyeHeight, player.z);

      const toP = new THREE.Vector3(camera.position.x - suspect.position.x, 0, camera.position.z - suspect.position.z);
      const dist = toP.length();
      const base = suspectState.speedBase;
      let rbFactor = 1;
      let rbLabel = 'neutral';
      if (dist > 42) { rbFactor = .84; rbLabel = 'assist player'; }
      else if (dist < 14) { rbFactor = 1.2; rbLabel = 'suspect evasive'; }

      suspectState.hideTimer -= dt;
      if (suspectState.mode === 'tag') {
        if (suspectState.hideTimer <= 0) {
          suspectState.visible = !suspectState.visible;
          suspectState.hideTimer = suspectState.visible ? 10 : 6;
          if (!suspectState.visible) {
            const hs = hideSpots[(Math.random() * hideSpots.length) | 0];
            placeSuspect(hs.x, hs.z);
          }
        }
      } else {
        suspectState.visible = true;
      }
      suspect.visible = suspectState.visible;

      const wp = suspectState.path[suspectState.wp];
      const target = new THREE.Vector3(wp[0], terrainHeight(wp[0], wp[1]), wp[1]);
      const dir = target.clone().sub(suspect.position); dir.y = 0;
      if (dir.length() < 2.5) suspectState.wp = (suspectState.wp + 1) % suspectState.path.length;
      dir.normalize();
      if (dist < 18) {
        const away = suspect.position.clone().sub(camera.position); away.y = 0; away.normalize();
        dir.lerp(away, .55 + Math.sin(t * 5.5) * .15).normalize();
      }
      const sSpeed = base * rbFactor * (suspectState.visible ? 1 : 0.65);
      suspect.position.x += dir.x * sSpeed * dt;
      suspect.position.z += dir.z * sSpeed * dt;
      suspect.position.y = terrainHeight(suspect.position.x, suspect.position.z);
      suspect.rotation.y = Math.atan2(dir.x, dir.z);

      // ambient animations
      npcs.forEach((npc, i) => {
        if (!npc.mesh.visible) return;
        npc.mesh.position.y = npc.baseY + Math.sin(t * 1.2 + npc.phase) * 0.02;
        npc.mesh.rotation.y = Math.sin(t * .45 + i) * 0.35;
      });
      animatedProps.forEach((obj, i) => {
        if (!obj.visible) return;
        obj.position.y += Math.sin((t + i) * 1.6) * 0.0009;
        obj.rotation.y += dt * (0.3 + i * 0.04);
      });

      ui.dist.textContent = dist.toFixed(1);
      ui.rb.textContent = rbLabel;
      ui.time.textContent = ((performance.now() - suspectState.started) / 1000).toFixed(1);

      if (suspectState.mode === 'chase' && dist < 2.2) tryTag(false);
      if (suspectState.mode === 'tag' && dist < 3.5 && suspectState.visible) ui.msg.textContent = 'Press E to tag suspect!';

      const day = Math.sin(t * .04) * .5 + .5;
      hemi.intensity = .35 + day * .9; sun.intensity = .25 + day * 1.0;
      sun.position.set(Math.cos(t * .04) * 120, 20 + day * 130, Math.sin(t * .04) * 90);
      sunGlow.position.copy(sun.position).multiplyScalar(.9);
      water.material.color.set(day > .5 ? 0x2f86bc : 0x1f4f7d);
      clouds.forEach((c, i) => { c.position.x += dt * (0.8 + i * .02); if (c.position.x > 200) c.position.x = -200; });

      updateCulling(camera.position.x, camera.position.z);
      renderer.render(scene, camera);
    }
    animate();

    addEventListener('resize', () => {
      camera.aspect = innerWidth / innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(innerWidth, innerHeight);
    });

    refreshAssetStatus();
    window.__assetLog = assetLog;
    window.__suspectVisualLoaded = () => suspectVisualLoaded;
  </script>
</body>
</html>
